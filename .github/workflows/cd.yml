name: ğŸš€ CD - Continuous Deployment

on:
  workflow_run:
    workflows: ["ğŸ”¬ CI - Continuous Integration"]
    types: [completed]
    branches: [main]

permissions:
  contents: read
  packages: read
  id-token: write

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: josojmf/ai-firefighter
  DEPLOYMENT_TIMEOUT: 600  # 10 minutes

jobs:
  # ============================================
  # JOB 1: Pre-deployment Validation
  # ============================================
  pre-deployment:
    name: ğŸ” Pre-deployment Validation
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    
    outputs:
      deployment_id: ${{ steps.generate-id.outputs.deployment_id }}
      current_version: ${{ steps.current-version.outputs.version }}
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # âœ… Obtener los Ãºltimos 2 commits para acceder a HEAD~1

      - name: ğŸ†” Generate deployment ID
        id: generate-id
        run: |
          DEPLOYMENT_ID="deploy-$(date +%Y%m%d-%H%M%S)-${{ github.sha }}"
          echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "ğŸ†” Deployment ID: $DEPLOYMENT_ID"

      - name: ğŸ” Validate required secrets
        run: |
          echo "ğŸ”’ Validating required secrets..."
          
          MISSING_SECRETS=()
          
          # Check each secret individually
          if [ -z "${{ secrets.PRODUCTION_SSH_KEY }}" ]; then
            MISSING_SECRETS+=("PRODUCTION_SSH_KEY")
          fi
          
          if [ -z "${{ secrets.PRODUCTION_HOST }}" ]; then
            MISSING_SECRETS+=("PRODUCTION_HOST")
          fi
          
          if [ -z "${{ secrets.MONGODB_URI }}" ]; then
            MISSING_SECRETS+=("MONGODB_URI")
          fi
          
          if [ -z "${{ secrets.JWT_SECRET }}" ]; then
            MISSING_SECRETS+=("JWT_SECRET")
          fi
          
          if [ -z "${{ secrets.SENDGRID_API_KEY }}" ]; then
            MISSING_SECRETS+=("SENDGRID_API_KEY")
          fi
          
          if [ -z "${{ secrets.ANTHROPIC_API_KEY }}" ]; then
            MISSING_SECRETS+=("ANTHROPIC_API_KEY")
          fi
          
          # Report results
          if [ ${#MISSING_SECRETS[@]} -ne 0 ]; then
            echo "âŒ Missing required secrets:"
            printf '%s\n' "${MISSING_SECRETS[@]}"
            exit 1
          fi
          
          echo "âœ… All required secrets are configured"

      - name: ğŸ³ Verify Docker images exist
        run: |
          echo "ğŸ” Verifying Docker images..."
          echo "â° Will wait up to 10 minutes for images to be available..."
          
          SERVICES="frontend backend backoffice"
          IMAGE_TAG="${{ github.sha }}"
          SHORT_SHA="${IMAGE_TAG:0:7}"
          
          MAX_RETRIES=60
          RETRY_DELAY=10
          
          for service in $SERVICES; do
            IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-${service}:main-${SHORT_SHA}"
            echo "Checking: $IMAGE"
            
            SUCCESS=false
            for attempt in $(seq 1 $MAX_RETRIES); do
              if docker manifest inspect $IMAGE > /dev/null 2>&1; then
                echo "âœ… Image exists: $service (attempt $attempt)"
                SUCCESS=true
                break
              fi
              if [ $attempt -eq 1 ]; then
                echo "â³ Image not ready yet, waiting for CI to finish building..."
              fi
              if [ $attempt -lt $MAX_RETRIES ]; then
                sleep $RETRY_DELAY
              fi
            done
            
            if [ "$SUCCESS" != "true" ]; then
              echo "âŒ Image not found after $MAX_RETRIES retries: $IMAGE"
              echo "Check if CI workflow completed successfully"
              exit 1
            fi
          done
          
          echo "âœ… All Docker images verified and ready"

      - name: ğŸ“‹ Get current production version
        id: current-version
        run: |
          # âœ… Manejar el caso cuando no hay commit previo (primer deploy)
          CURRENT_VERSION=$(git rev-parse HEAD~1 2>/dev/null || git rev-parse HEAD)
          echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "ğŸ“Œ Current production version: $CURRENT_VERSION"

      - name: ğŸ“Š Create deployment record
        run: |
          echo "ğŸ“ Creating deployment record..."
          cat > deployment-info.json <<EOF
          {
            "deployment_id": "${{ steps.generate-id.outputs.deployment_id }}",
            "commit_sha": "${{ github.sha }}",
            "commit_message": "${{ github.event.head_commit.message }}",
            "deployer": "${{ github.actor }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "previous_version": "${{ steps.current-version.outputs.version }}",
            "status": "initiated"
          }
          EOF
          cat deployment-info.json

      - name: ğŸ“¤ Upload deployment info
        uses: actions/upload-artifact@v4
        with:
          name: deployment-info
          path: deployment-info.json
          retention-days: 90

  # ============================================
  # JOB 2: Backup Current State
  # ============================================
  backup-state:
    name: ğŸ’¾ Backup Current State
    runs-on: ubuntu-latest
    needs: [pre-deployment]
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      - name: ğŸ’¾ Backup current deployment
        run: |
          echo "ğŸ’¾ Backing up current deployment state..."
          
          ssh root@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
            # Create backup directory
            BACKUP_DIR="/root/backups/$(date +%Y%m%d-%H%M%S)"
            mkdir -p "$BACKUP_DIR"
            
            # Backup docker-compose files
            cp /root/docker-compose*.yml "$BACKUP_DIR/" 2>/dev/null || true
            
            # Backup environment files
            cp /root/.env* "$BACKUP_DIR/" 2>/dev/null || true
            
            # Export current running containers info
            docker ps --format "{{.Names}}: {{.Image}}" > "$BACKUP_DIR/running-containers.txt"
            
            # Save current service states
            docker service ls --format "{{.Name}}: {{.Replicas}}" > "$BACKUP_DIR/service-states.txt" 2>/dev/null || true
            
            # Keep only last 10 backups
            cd /root/backups
            ls -t | tail -n +11 | xargs -r rm -rf
            
            echo "âœ… Backup completed: $BACKUP_DIR"
          ENDSSH

      - name: ğŸ“Š Verify backup
        run: |
          ssh root@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
            LATEST_BACKUP=$(ls -t /root/backups | head -n 1)
            echo "ğŸ“ Latest backup: $LATEST_BACKUP"
            echo "ğŸ“‹ Backup contents:"
            ls -lah "/root/backups/$LATEST_BACKUP"
          ENDSSH

  # ============================================
  # JOB 3: Health Check Current Production
  # ============================================
  health-check-pre:
    name: ğŸ¥ Health Check (Pre-deployment)
    runs-on: ubuntu-latest
    needs: [pre-deployment]
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ¥ Check production health
        run: |
          echo "ğŸ¥ Checking current production health..."
          
          # Check frontend (usar / en vez de /health)
          FRONTEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.PRODUCTION_HOST }}:8000/ || echo "000")
          echo "Frontend health: $FRONTEND_STATUS"
          
          # Check API (usar /api/health en vez de /health)
          API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.PRODUCTION_HOST }}:5000/api/health || echo "000")
          echo "API health: $API_STATUS"
          
          # Check BackOffice
          BO_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.PRODUCTION_HOST }}:3001/health || echo "000")
          echo "BackOffice health: $BO_STATUS"
          
          # Create health report
          cat > health-report-pre.json <<EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "frontend": "$FRONTEND_STATUS",
            "backend": "$API_STATUS",
            "backoffice": "$BO_STATUS",
            "overall": "checked"
          }
          EOF
          
          cat health-report-pre.json
          
          echo "âœ… Pre-deployment health check completed"

      - name: ğŸ“¤ Upload health report
        uses: actions/upload-artifact@v4
        with:
          name: health-report-pre
          path: health-report-pre.json
          retention-days: 30

  # ============================================
  # JOB 4: Deploy to Production
  # ============================================
  deploy-production:
    name: ğŸš€ Deploy to Production
    runs-on: ubuntu-latest
    needs: [pre-deployment, backup-state, health-check-pre]
    environment:
      name: production
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      - name: ğŸ“¤ Copy deployment files
        run: |
          echo "ğŸ“¤ Copying deployment files to server..."
          
          # Copy docker-compose files
          scp docker-compose*.yml root@${{ secrets.PRODUCTION_HOST }}:/root/
          
          echo "âœ… Files copied successfully"

      - name: ğŸ” Configure environment variables
        run: |
          ssh root@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
            echo "ğŸ” Configuring environment variables..."
            
            # Create .env file with all secrets
            cat > /root/.env <<EOF
          # MongoDB Configuration
          MONGODB_URI=${{ secrets.MONGODB_URI }}
          
          # JWT Configuration
          JWT_SECRET_KEY=${{ secrets.JWT_SECRET }}
          SESSION_SECRET_KEY=${{ secrets.FRONTEND_SECRET_KEY }}
          BO_SESSION_SECRET=${{ secrets.BACKOFFICE_SECRET_KEY }}
          
          # Email Configuration
          SENDGRID_API_KEY=${{ secrets.SENDGRID_API_KEY }}
          SENDGRID_FROM_EMAIL=${{ secrets.SENDGRID_SENDER_EMAIL }}
          
          # AI Configuration
          ANTHROPIC_API_KEY=${{ secrets.ANTHROPIC_API_KEY }}
          
          # Application URLs
          FRONTEND_URL=http://localhost:8000
          API_URL=http://localhost:5000
          BO_URL=http://localhost:3001
          
          # Docker Configuration
          IMAGE_TAG=${{ github.sha }}
          REGISTRY=${{ env.REGISTRY }}
          IMAGE_PREFIX=${{ env.IMAGE_PREFIX }}
          
          # Deployment Info
          DEPLOYMENT_ID=${{ needs.pre-deployment.outputs.deployment_id }}
          COMMIT_SHA=${{ github.sha }}
          DEPLOYED_AT=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          EOF
          
            echo "âœ… Environment configured"
          ENDSSH

      - name: ğŸ“¥ Pull new Docker images
        run: |
          ssh root@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
            echo "ğŸ“¥ Pulling new Docker images..."
            
            SHORT_SHA="${{ github.sha }}"
            SHORT_SHA="${SHORT_SHA:0:7}"
            
            echo "${{ secrets.GHCR_TOKEN }}" | docker login ghcr.io -u ${{ github.repository_owner }} --password-stdin
            
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-frontend:main-${SHORT_SHA}
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-backend:main-${SHORT_SHA}
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-backoffice:main-${SHORT_SHA}
            
            echo "âœ… Images pulled successfully"
          ENDSSH

      - name: ğŸ”„ Rolling update deployment
        run: |
          ssh root@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
            echo "ğŸ”„ Starting rolling update..."
            
            # Update services one by one with health checks
            SERVICES=("backend" "frontend" "backoffice")
            
            for service in "${SERVICES[@]}"; do
              echo "ğŸ“¦ Updating $service..."
              
              # Update the service using prod compose file
              docker-compose -f docker-compose.prod.yml up -d --no-deps $service
              
              # Wait for service to be healthy
              echo "â³ Waiting for $service to be healthy..."
              sleep 15
              
              # Check service health
              case $service in
                frontend)
                  HEALTH_URL="http://localhost:8000/"
                  ;;
                backend)
                  HEALTH_URL="http://localhost:5000/api/health"
                  ;;
                backoffice)
                  HEALTH_URL="http://localhost:3001/health"
                  ;;
              esac
              
              # Retry health check up to 30 times (5 minutes)
              for i in {1..30}; do
                if curl -f -s "$HEALTH_URL" > /dev/null 2>&1; then
                  echo "âœ… $service is healthy"
                  break
                fi
                
                if [ $i -eq 30 ]; then
                  echo "âŒ $service failed health check after 5 minutes"
                  exit 1
                fi
                
                echo "â³ Attempt $i/30: Waiting for $service..."
                sleep 10
              done
            done
            
            echo "âœ… All services updated successfully"
          ENDSSH

      - name: ğŸ§¹ Cleanup old images
        run: |
          ssh root@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
            echo "ğŸ§¹ Cleaning up old Docker images..."
            
            # Remove dangling images
            docker image prune -f
            
            # Remove old images (keep last 3 versions)
            docker images --format "{{.Repository}}:{{.Tag}}" | \
              grep "${{ env.IMAGE_PREFIX }}" | \
              tail -n +4 | \
              xargs -r docker rmi || true
            
            echo "âœ… Cleanup completed"
          ENDSSH

  # ============================================
  # JOB 5: Post-deployment Health Check
  # ============================================
  health-check-post:
    name: ğŸ¥ Health Check (Post-deployment)
    runs-on: ubuntu-latest
    needs: [deploy-production]
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: â³ Wait for services to stabilize
        run: |
          echo "â³ Waiting 30 seconds for services to stabilize..."
          sleep 30

      - name: ğŸ¥ Comprehensive health check
        id: health-check
        run: |
          echo "ğŸ¥ Running comprehensive health checks..."
          
          MAX_RETRIES=10
          RETRY_DELAY=10
          ALL_HEALTHY=false
          
          for i in $(seq 1 $MAX_RETRIES); do
            echo "ğŸ”„ Health check attempt $i/$MAX_RETRIES"
            
            # Check frontend (usar / en vez de /health)
            FRONTEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.PRODUCTION_HOST }}:8000/ || echo "000")
            echo "  Frontend: $FRONTEND_STATUS"
            
            # Check API (usar /api/health en vez de /health)
            API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.PRODUCTION_HOST }}:5000/api/health || echo "000")
            echo "  API: $API_STATUS"
            
            # Check BackOffice
            BO_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.PRODUCTION_HOST }}:3001/health || echo "000")
            echo "  BackOffice: $BO_STATUS"
            
            # Check if all services are healthy
            if [ "$FRONTEND_STATUS" = "200" ] && [ "$API_STATUS" = "200" ] && [ "$BO_STATUS" = "200" ]; then
              echo "âœ… All services are healthy!"
              ALL_HEALTHY=true
              break
            fi
            
            if [ $i -lt $MAX_RETRIES ]; then
              echo "â³ Waiting ${RETRY_DELAY}s before retry..."
              sleep $RETRY_DELAY
            fi
          done
          
          if [ "$ALL_HEALTHY" = false ]; then
            echo "âŒ Health check failed after $MAX_RETRIES attempts"
            echo "health_status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "health_status=success" >> $GITHUB_OUTPUT

      - name: ğŸ“Š Create health report
        if: always()
        run: |
          # Get detailed service info (corregir URLs)
          FRONTEND_RESPONSE=$(curl -s http://${{ secrets.PRODUCTION_HOST }}:8000/ || echo "{}")
          API_RESPONSE=$(curl -s http://${{ secrets.PRODUCTION_HOST }}:5000/api/health || echo "{}")
          BO_RESPONSE=$(curl -s http://${{ secrets.PRODUCTION_HOST }}:3001/health || echo "{}")
          
          cat > health-report-post.json <<EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "deployment_id": "${{ needs.pre-deployment.outputs.deployment_id }}",
            "status": "${{ steps.health-check.outputs.health_status }}",
            "services": {
              "frontend": $FRONTEND_RESPONSE,
              "backend": $API_RESPONSE,
              "backoffice": $BO_RESPONSE
            }
          }
          EOF
          
          cat health-report-post.json

      - name: ğŸ“¤ Upload health report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: health-report-post
          path: health-report-post.json
          retention-days: 30

  # ============================================
  # JOB 6: Smoke Tests
  # ============================================
  smoke-tests:
    name: ğŸ’¨ Smoke Tests
    runs-on: ubuntu-latest
    needs: [health-check-post]
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: ğŸ“¦ Install test dependencies
        run: |
          pip install requests pytest

      - name: ğŸ’¨ Run smoke tests
        run: |
          echo "ğŸ’¨ Running smoke tests..."
          
          python << 'PYTHON'
          import requests
          import sys
          
          HOST = "${{ secrets.PRODUCTION_HOST }}"
          
          tests = [
              ("Frontend root", f"http://{HOST}:8000/", 200),
              ("API health", f"http://{HOST}:5000/api/health", 200),
              ("API root", f"http://{HOST}:5000/", 200),
              ("BackOffice health", f"http://{HOST}:3001/health", 200),
          ]
          
          failed = []
          
          for name, url, expected_status in tests:
              try:
                  response = requests.get(url, timeout=10)
                  if response.status_code == expected_status:
                      print(f"âœ… {name}: OK")
                  else:
                      print(f"âŒ {name}: Expected {expected_status}, got {response.status_code}")
                      failed.append(name)
              except Exception as e:
                  print(f"âŒ {name}: Error - {e}")
                  failed.append(name)
          
          if failed:
              print(f"\nâŒ Failed tests: {', '.join(failed)}")
              sys.exit(1)
          else:
              print("\nâœ… All smoke tests passed!")
          PYTHON

  # ============================================
  # JOB 7: Deployment Success
  # ============================================
  deployment-success:
    name: âœ… Deployment Success
    runs-on: ubuntu-latest
    needs: [pre-deployment, deploy-production, health-check-post, smoke-tests]
    
    steps:
      - name: ğŸ“¥ Download deployment info
        uses: actions/download-artifact@v4
        with:
          name: deployment-info

      - name: ğŸ“ Update deployment record
        run: |
          echo "ğŸ“ Updating deployment record..."
          
          jq '.status = "success" | .completed_at = "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"' \
            deployment-info.json > deployment-info-final.json
          
          cat deployment-info-final.json

      - name: ğŸ‰ Success notification
        run: |
          echo "# ğŸ‰ Deployment Successful!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment ID:** ${{ needs.pre-deployment.outputs.deployment_id }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Time:** $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Services Status" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Frontend: http://${{ secrets.PRODUCTION_HOST }}:8000" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… API: http://${{ secrets.PRODUCTION_HOST }}:5000" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… BackOffice: http://${{ secrets.PRODUCTION_HOST }}:3001" >> $GITHUB_STEP_SUMMARY

      - name: ğŸ“¢ Create deployment annotation
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createCommitComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha,
              body: `ğŸš€ Successfully deployed to production\n\nDeployment ID: ${{ needs.pre-deployment.outputs.deployment_id }}\nTime: ${new Date().toISOString()}`
            });

  # ============================================
  # JOB 8: Deployment Failure Handler
  # ============================================
  deployment-failure:
    name: âŒ Deployment Failure Handler
    runs-on: ubuntu-latest
    needs: [deploy-production, health-check-post]
    if: failure()
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      - name: ğŸ“Š Collect failure logs
        run: |
          ssh root@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
            echo "ğŸ“Š Collecting failure logs..."
            
            mkdir -p /root/failed-deployments
            FAILURE_DIR="/root/failed-deployments/$(date +%Y%m%d-%H%M%S)"
            mkdir -p "$FAILURE_DIR"
            
            # Collect service logs
            docker-compose logs --tail=500 > "$FAILURE_DIR/docker-logs.txt"
            
            # Collect service status
            docker ps -a > "$FAILURE_DIR/container-status.txt"
            docker service ls > "$FAILURE_DIR/service-status.txt" 2>/dev/null || true
            
            # Collect system info
            df -h > "$FAILURE_DIR/disk-usage.txt"
            free -h > "$FAILURE_DIR/memory-usage.txt"
            
            echo "âœ… Logs collected: $FAILURE_DIR"
          ENDSSH

      - name: âŒ Failure notification
        run: |
          echo "# âŒ Deployment Failed!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Failed at:** $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Review the logs in the failed-deployments directory" >> $GITHUB_STEP_SUMMARY
          echo "2. Check health check results" >> $GITHUB_STEP_SUMMARY
          echo "3. Consider triggering a rollback if needed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âš ï¸ **System remains on previous version**" >> $GITHUB_STEP_SUMMARY

      - name: ğŸ“¢ Create failure annotation
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createCommitComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha,
              body: `âŒ Deployment failed\n\nTime: ${new Date().toISOString()}\n\nâš ï¸ System remains on previous version. Review logs and consider rollback if needed.`
            });
