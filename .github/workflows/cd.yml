name: üöÄ CD - Continuous Deployment

on:
  workflow_run:
    workflows: ["üî¨ CI - Continuous Integration"]
    types: [completed]
    branches: [main]

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: josojmf/firefighter
  DEPLOYMENT_TIMEOUT: 600  # 10 minutes

jobs:
  # ============================================
  # JOB 1: Pre-deployment Validation
  # ============================================
  pre-deployment:
    name: üîç Pre-deployment Validation
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    
    outputs:
      deployment_id: ${{ steps.generate-id.outputs.deployment_id }}
      current_version: ${{ steps.current-version.outputs.version }}
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üÜî Generate deployment ID
        id: generate-id
        run: |
          DEPLOYMENT_ID="deploy-$(date +%Y%m%d-%H%M%S)-${{ github.sha }}"
          echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "üÜî Deployment ID: $DEPLOYMENT_ID"

      - name: üîç Validate required secrets
        run: |
          echo "üîí Validating required secrets..."
          
          MISSING_SECRETS=()
          
          # Check each secret individually
          if [ -z "${{ secrets.PRODUCTION_SSH_KEY }}" ]; then
            MISSING_SECRETS+=("PRODUCTION_SSH_KEY")
          fi
          
          if [ -z "${{ secrets.PRODUCTION_HOST }}" ]; then
            MISSING_SECRETS+=("PRODUCTION_HOST")
          fi
          
          if [ -z "${{ secrets.MONGODB_URI }}" ]; then
            MISSING_SECRETS+=("MONGODB_URI")
          fi
          
          if [ -z "${{ secrets.JWT_SECRET }}" ]; then
            MISSING_SECRETS+=("JWT_SECRET")
          fi
          
          if [ -z "${{ secrets.SENDGRID_API_KEY }}" ]; then
            MISSING_SECRETS+=("SENDGRID_API_KEY")
          fi
          
          if [ -z "${{ secrets.ANTHROPIC_API_KEY }}" ]; then
            MISSING_SECRETS+=("ANTHROPIC_API_KEY")
          fi
          
          # Report results
          if [ ${#MISSING_SECRETS[@]} -ne 0 ]; then
            echo "‚ùå Missing required secrets:"
            printf '%s\n' "${MISSING_SECRETS[@]}"
            exit 1
          fi
          
          echo "‚úÖ All required secrets are configured"

      - name: üê≥ Verify Docker images exist
        run: |
          echo "üîç Verifying Docker images..."
          
          SERVICES=("frontend" "api" "backoffice")
          IMAGE_TAG="${{ github.sha }}"
          
          for service in "${SERVICES[@]}"; do
            IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-${service}:main-${IMAGE_TAG}"
            echo "Checking: $IMAGE"
            
            # Try to pull image metadata
            if ! docker manifest inspect "$IMAGE" > /dev/null 2>&1; then
              echo "‚ùå Image not found: $IMAGE"
              exit 1
            fi
            
            echo "‚úÖ Image exists: $service"
          done
          
          echo "‚úÖ All Docker images verified"

      - name: üìã Get current production version
        id: current-version
        run: |
          # This would typically query your server or deployment system
          # For now, we'll use the previous commit
          CURRENT_VERSION=$(git rev-parse HEAD~1)
          echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "üìå Current production version: $CURRENT_VERSION"

      - name: üìä Create deployment record
        run: |
          echo "üìù Creating deployment record..."
          cat > deployment-info.json <<EOF
          {
            "deployment_id": "${{ steps.generate-id.outputs.deployment_id }}",
            "commit_sha": "${{ github.sha }}",
            "commit_message": "${{ github.event.head_commit.message }}",
            "deployer": "${{ github.actor }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "previous_version": "${{ steps.current-version.outputs.version }}",
            "status": "initiated"
          }
          EOF
          cat deployment-info.json

      - name: üì§ Upload deployment info
        uses: actions/upload-artifact@v4
        with:
          name: deployment-info
          path: deployment-info.json
          retention-days: 90

  # ============================================
  # JOB 2: Backup Current State
  # ============================================
  backup-state:
    name: üíæ Backup Current State
    runs-on: ubuntu-latest
    needs: [pre-deployment]
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîß Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      - name: üíæ Backup current deployment
        run: |
          echo "üíæ Backing up current deployment state..."
          
          ssh root@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
            # Create backup directory
            BACKUP_DIR="/root/backups/$(date +%Y%m%d-%H%M%S)"
            mkdir -p "$BACKUP_DIR"
            
            # Backup docker-compose files
            cp /root/docker-compose*.yml "$BACKUP_DIR/" 2>/dev/null || true
            
            # Backup environment files
            cp /root/.env* "$BACKUP_DIR/" 2>/dev/null || true
            
            # Export current running containers info
            docker ps --format "{{.Names}}: {{.Image}}" > "$BACKUP_DIR/running-containers.txt"
            
            # Save current service states
            docker service ls --format "{{.Name}}: {{.Replicas}}" > "$BACKUP_DIR/service-states.txt" 2>/dev/null || true
            
            # Keep only last 10 backups
            cd /root/backups
            ls -t | tail -n +11 | xargs -r rm -rf
            
            echo "‚úÖ Backup completed: $BACKUP_DIR"
            echo "BACKUP_PATH=$BACKUP_DIR" >> $GITHUB_ENV
          ENDSSH

      - name: üìä Verify backup
        run: |
          ssh root@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
            LATEST_BACKUP=$(ls -t /root/backups | head -n 1)
            echo "üìÅ Latest backup: $LATEST_BACKUP"
            echo "üìã Backup contents:"
            ls -lah "/root/backups/$LATEST_BACKUP"
          ENDSSH

  # ============================================
  # JOB 3: Health Check Current Production
  # ============================================
  health-check-pre:
    name: üè• Health Check (Pre-deployment)
    runs-on: ubuntu-latest
    needs: [pre-deployment]
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üè• Check production health
        run: |
          echo "üè• Checking current production health..."
          
          # Check frontend
          FRONTEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.PRODUCTION_HOST }}:8000/health || echo "000")
          echo "Frontend health: $FRONTEND_STATUS"
          
          # Check API
          API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.PRODUCTION_HOST }}:5000/health || echo "000")
          echo "API health: $API_STATUS"
          
          # Check BackOffice
          BO_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.PRODUCTION_HOST }}:3001/health || echo "000")
          echo "BackOffice health: $BO_STATUS"
          
          # Create health report
          cat > health-report-pre.json <<EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "frontend": "$FRONTEND_STATUS",
            "api": "$API_STATUS",
            "backoffice": "$BO_STATUS",
            "overall": "checked"
          }
          EOF
          
          cat health-report-pre.json
          
          echo "‚úÖ Pre-deployment health check completed"

      - name: üì§ Upload health report
        uses: actions/upload-artifact@v4
        with:
          name: health-report-pre
          path: health-report-pre.json
          retention-days: 30

  # ============================================
  # JOB 4: Deploy to Production
  # ============================================
  deploy-production:
    name: üöÄ Deploy to Production
    runs-on: ubuntu-latest
    needs: [pre-deployment, backup-state, health-check-pre]
    environment:
      name: production
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîß Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      - name: üì§ Copy deployment files
        run: |
          echo "üì§ Copying deployment files to server..."
          
          # Copy docker-compose files
          scp docker-compose*.yml root@${{ secrets.PRODUCTION_HOST }}:/root/
          
          # Copy environment templates
          scp production.env root@${{ secrets.PRODUCTION_HOST }}:/root/.env.production
          
          echo "‚úÖ Files copied successfully"

      - name: üîê Configure environment variables
        run: |
          ssh root@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
            echo "üîê Configuring environment variables..."
            
            # Create .env file with all secrets
            cat > /root/.env <<EOF
          # MongoDB Configuration
          MONGODB_URI=${{ secrets.MONGODB_URI }}
          
          # JWT Configuration
          JWT_SECRET_KEY=${{ secrets.JWT_SECRET }}
          SESSION_SECRET_KEY=${{ secrets.FRONTEND_SECRET_KEY }}
          BO_SESSION_SECRET=${{ secrets.BACKOFFICE_SECRET_KEY }}
          
          # Email Configuration
          SENDGRID_API_KEY=${{ secrets.SENDGRID_API_KEY }}
          SENDGRID_FROM_EMAIL=${{ secrets.SENDGRID_SENDER_EMAIL }}
          
          # AI Configuration
          ANTHROPIC_API_KEY=${{ secrets.ANTHROPIC_API_KEY }}
          
          # Application URLs
          FRONTEND_URL=http://localhost:8000
          API_URL=http://localhost:5000
          BO_URL=http://localhost:3001
          
          # Docker Configuration
          IMAGE_TAG=${{ github.sha }}
          REGISTRY=${{ env.REGISTRY }}
          IMAGE_PREFIX=${{ env.IMAGE_PREFIX }}
          
          # Deployment Info
          DEPLOYMENT_ID=${{ needs.pre-deployment.outputs.deployment_id }}
          COMMIT_SHA=${{ github.sha }}
          DEPLOYED_AT=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          EOF
          
            echo "‚úÖ Environment configured"
          ENDSSH

      - name: üê≥ Pull new Docker images
        run: |
          ssh root@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
            echo "üê≥ Pulling new Docker images..."
            
            # Login to GitHub Container Registry
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            
            # Pull new images
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-frontend:main-${{ github.sha }}
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-api:main-${{ github.sha }}
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-backoffice:main-${{ github.sha }}
            
            echo "‚úÖ Images pulled successfully"
          ENDSSH

      - name: üîÑ Rolling update deployment
        run: |
          ssh root@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
            echo "üîÑ Starting rolling update..."
            
            # Update services one by one with health checks
            SERVICES=("backend" "frontend" "backoffice")
            
            for service in "${SERVICES[@]}"; do
              echo "üì¶ Updating $service..."
              
              # Update the service using prod compose file
              docker-compose -f docker-compose.prod.yml up -d --no-deps $service
              
              # Wait for service to be healthy
              echo "‚è≥ Waiting for $service to be healthy..."
              sleep 15
              
              # Check service health
              case $service in
                frontend)
                  HEALTH_URL="http://localhost:8000/"
                  ;;
                backend)
                  HEALTH_URL="http://localhost:5000/api/health"
                  ;;
                backoffice)
                  HEALTH_URL="http://localhost:3001/health"
                  ;;
              esac
              
              # Retry health check up to 30 times (5 minutes)
              for i in {1..30}; do
                if curl -f -s "$HEALTH_URL" > /dev/null 2>&1; then
                  echo "‚úÖ $service is healthy"
                  break
                fi
                
                if [ $i -eq 30 ]; then
                  echo "‚ùå $service failed health check after 5 minutes"
                  exit 1
                fi
                
                echo "‚è≥ Attempt $i/30: Waiting for $service..."
                sleep 10
              done
            done
            
            echo "‚úÖ All services updated successfully"
          ENDSSH

      - name: üßπ Cleanup old images
        run: |
          ssh root@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
            echo "üßπ Cleaning up old Docker images..."
            
            # Remove dangling images
            docker image prune -f
            
            # Remove old images (keep last 3 versions)
            docker images --format "{{.Repository}}:{{.Tag}}" | \
              grep "${{ env.IMAGE_PREFIX }}" | \
              tail -n +4 | \
              xargs -r docker rmi || true
            
            echo "‚úÖ Cleanup completed"
          ENDSSH

  # ============================================
  # JOB 5: Post-deployment Health Check
  # ============================================
  health-check-post:
    name: üè• Health Check (Post-deployment)
    runs-on: ubuntu-latest
    needs: [deploy-production]
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: ‚è≥ Wait for services to stabilize
        run: |
          echo "‚è≥ Waiting 30 seconds for services to stabilize..."
          sleep 30

      - name: üè• Comprehensive health check
        id: health-check
        run: |
          echo "üè• Running comprehensive health checks..."
          
          MAX_RETRIES=10
          RETRY_DELAY=10
          ALL_HEALTHY=false
          
          for i in $(seq 1 $MAX_RETRIES); do
            echo "üîÑ Health check attempt $i/$MAX_RETRIES"
            
            # Check frontend
            FRONTEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.PRODUCTION_HOST }}:8000/health || echo "000")
            echo "  Frontend: $FRONTEND_STATUS"
            
            # Check API
            API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.PRODUCTION_HOST }}:5000/health || echo "000")
            echo "  API: $API_STATUS"
            
            # Check BackOffice
            BO_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.PRODUCTION_HOST }}:3001/health || echo "000")
            echo "  BackOffice: $BO_STATUS"
            
            # Check if all services are healthy
            if [ "$FRONTEND_STATUS" = "200" ] && [ "$API_STATUS" = "200" ] && [ "$BO_STATUS" = "200" ]; then
              echo "‚úÖ All services are healthy!"
              ALL_HEALTHY=true
              break
            fi
            
            if [ $i -lt $MAX_RETRIES ]; then
              echo "‚è≥ Waiting ${RETRY_DELAY}s before retry..."
              sleep $RETRY_DELAY
            fi
          done
          
          if [ "$ALL_HEALTHY" = false ]; then
            echo "‚ùå Health check failed after $MAX_RETRIES attempts"
            echo "health_status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "health_status=success" >> $GITHUB_OUTPUT

      - name: üìä Create health report
        if: always()
        run: |
          # Get detailed service info
          FRONTEND_RESPONSE=$(curl -s http://${{ secrets.PRODUCTION_HOST }}:8000/health || echo "{}")
          API_RESPONSE=$(curl -s http://${{ secrets.PRODUCTION_HOST }}:5000/health || echo "{}")
          BO_RESPONSE=$(curl -s http://${{ secrets.PRODUCTION_HOST }}:3001/health || echo "{}")
          
          cat > health-report-post.json <<EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "deployment_id": "${{ needs.pre-deployment.outputs.deployment_id }}",
            "status": "${{ steps.health-check.outputs.health_status }}",
            "services": {
              "frontend": $FRONTEND_RESPONSE,
              "api": $API_RESPONSE,
              "backoffice": $BO_RESPONSE
            }
          }
          EOF
          
          cat health-report-post.json

      - name: üì§ Upload health report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: health-report-post
          path: health-report-post.json
          retention-days: 30

  # ============================================
  # JOB 6: Smoke Tests
  # ============================================
  smoke-tests:
    name: üí® Smoke Tests
    runs-on: ubuntu-latest
    needs: [health-check-post]
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üêç Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: üì¶ Install test dependencies
        run: |
          pip install requests pytest

      - name: üí® Run smoke tests
        run: |
          echo "üí® Running smoke tests..."
          
          python << 'PYTHON'
          import requests
          import sys
          
          HOST = "${{ secrets.PRODUCTION_HOST }}"
          
          tests = [
              ("Frontend root", f"http://{HOST}:8000/", 200),
              ("API health", f"http://{HOST}:5000/health", 200),
              ("API docs", f"http://{HOST}:5000/api/docs", 200),
              ("BackOffice health", f"http://{HOST}:3001/health", 200),
          ]
          
          failed = []
          
          for name, url, expected_status in tests:
              try:
                  response = requests.get(url, timeout=10)
                  if response.status_code == expected_status:
                      print(f"‚úÖ {name}: OK")
                  else:
                      print(f"‚ùå {name}: Expected {expected_status}, got {response.status_code}")
                      failed.append(name)
              except Exception as e:
                  print(f"‚ùå {name}: Error - {e}")
                  failed.append(name)
          
          if failed:
              print(f"\n‚ùå Failed tests: {', '.join(failed)}")
              sys.exit(1)
          else:
              print("\n‚úÖ All smoke tests passed!")
          PYTHON

  # ============================================
  # JOB 7: Deployment Success
  # ============================================
  deployment-success:
    name: ‚úÖ Deployment Success
    runs-on: ubuntu-latest
    needs: [pre-deployment, deploy-production, health-check-post, smoke-tests]
    
    steps:
      - name: üì• Download deployment info
        uses: actions/download-artifact@v4
        with:
          name: deployment-info

      - name: üìù Update deployment record
        run: |
          echo "üìù Updating deployment record..."
          
          jq '.status = "success" | .completed_at = "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"' \
            deployment-info.json > deployment-info-final.json
          
          cat deployment-info-final.json

      - name: üéâ Success notification
        run: |
          echo "# üéâ Deployment Successful!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment ID:** ${{ needs.pre-deployment.outputs.deployment_id }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Time:** $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Services Status" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Frontend: http://${{ secrets.PRODUCTION_HOST }}:8000" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ API: http://${{ secrets.PRODUCTION_HOST }}:5000" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ BackOffice: http://${{ secrets.PRODUCTION_HOST }}:3001" >> $GITHUB_STEP_SUMMARY

      - name: üì¢ Create deployment annotation
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createCommitComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha,
              body: `üöÄ Successfully deployed to production\n\nDeployment ID: ${{ needs.pre-deployment.outputs.deployment_id }}\nTime: ${new Date().toISOString()}`
            });

  # ============================================
  # JOB 8: Deployment Failure Handler
  # ============================================
  deployment-failure:
    name: ‚ùå Deployment Failure Handler
    runs-on: ubuntu-latest
    needs: [deploy-production, health-check-post]
    if: failure()
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîß Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      - name: üìä Collect failure logs
        run: |
          ssh root@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
            echo "üìä Collecting failure logs..."
            
            mkdir -p /root/failed-deployments
            FAILURE_DIR="/root/failed-deployments/$(date +%Y%m%d-%H%M%S)"
            mkdir -p "$FAILURE_DIR"
            
            # Collect service logs
            docker-compose logs --tail=500 > "$FAILURE_DIR/docker-logs.txt"
            
            # Collect service status
            docker ps -a > "$FAILURE_DIR/container-status.txt"
            docker service ls > "$FAILURE_DIR/service-status.txt" 2>/dev/null || true
            
            # Collect system info
            df -h > "$FAILURE_DIR/disk-usage.txt"
            free -h > "$FAILURE_DIR/memory-usage.txt"
            
            echo "‚úÖ Logs collected: $FAILURE_DIR"
          ENDSSH

      - name: ‚ùå Failure notification
        run: |
          echo "# ‚ùå Deployment Failed!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Failed at:** $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Review the logs in the failed-deployments directory" >> $GITHUB_STEP_SUMMARY
          echo "2. Check health check results" >> $GITHUB_STEP_SUMMARY
          echo "3. Consider triggering a rollback if needed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚ö†Ô∏è **System remains on previous version**" >> $GITHUB_STEP_SUMMARY

      - name: üì¢ Create failure annotation
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createCommitComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha,
              body: `‚ùå Deployment failed\n\nTime: ${new Date().toISOString()}\n\n‚ö†Ô∏è System remains on previous version. Review logs and consider rollback if needed.`
            });