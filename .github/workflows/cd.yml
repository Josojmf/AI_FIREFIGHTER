name: CD Pipeline - Ultra Robust with Emergency Fallback

"on":
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment'
        required: false
        default: false
        type: boolean
      emergency_mode:
        description: 'Deploy in emergency mode (all services)'
        required: false
        default: false
        type: boolean

env:
  DOCKER_REGISTRY: ghcr.io
  DEPLOYMENT_TIMEOUT: 180
  MAX_DEPLOYMENT_ATTEMPTS: 2

jobs:
  pre_deployment:
    name: Pre-deployment Safety Check
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      deploy_mode: ${{ steps.check.outputs.deploy_mode }}

    steps:
      - name: Determine deployment strategy
        id: check
        run: |
          should_deploy="true"
          deploy_mode="normal"

          if [ "${{ github.event.inputs.emergency_mode }}" = "true" ]; then
            echo "Emergency deployment mode requested"
            deploy_mode="emergency"
          elif [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then
            echo "Force deployment requested"
            deploy_mode="force"
          else
            echo "Normal deployment mode"
            deploy_mode="normal"
          fi

          echo "should_deploy=$should_deploy" >> $GITHUB_OUTPUT
          echo "deploy_mode=$deploy_mode" >> $GITHUB_OUTPUT

  validate_environment:
    name: Validate Production Environment
    runs-on: ubuntu-latest
    needs: pre_deployment
    outputs:
      environment_ready: ${{ steps.validate.outputs.ready }}
      current_status: ${{ steps.validate.outputs.status }}

    steps:
      - name: Check required secrets
        run: |
          missing=()

          [ -z "${{ secrets.PRODUCTION_SSH_KEY }}" ] && missing+=("PRODUCTION_SSH_KEY")
          [ -z "${{ secrets.PRODUCTION_HOST }}" ] && missing+=("PRODUCTION_HOST")
          [ -z "${{ secrets.PRODUCTION_USER }}" ] && missing+=("PRODUCTION_USER")
          [ -z "${{ secrets.DB_USERNAME }}" ] && missing+=("DB_USERNAME")
          [ -z "${{ secrets.DB_PASSWORD }}" ] && missing+=("DB_PASSWORD")
          [ -z "${{ secrets.DB_CLUSTER }}" ] && missing+=("DB_CLUSTER")

          if [ ${#missing[@]} -ne 0 ]; then
            echo "Missing secrets: ${missing[*]}"
            exit 1
          fi

          echo "All secrets configured"

      - name: Validate production server
        id: validate
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

          if ! current_status=$(ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 \
            ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
              echo 'Server accessible'

              if curl -s --max-time 5 http://localhost:8000/ >/dev/null 2>&1; then
                echo 'FRONTEND_RUNNING=true'
              else
                echo 'FRONTEND_RUNNING=false'
              fi

              if curl -s --max-time 5 http://localhost:5000/ >/dev/null 2>&1; then
                echo 'BACKEND_RUNNING=true'
              else
                echo 'BACKEND_RUNNING=false'
              fi

              if command -v docker >/dev/null 2>&1; then
                echo 'DOCKER_AVAILABLE=true'
              else
                echo 'DOCKER_AVAILABLE=false'
              fi

              if [ -d /opt/firefighter-app ]; then
                echo 'DEPLOY_DIR_EXISTS=true'
              else
                echo 'DEPLOY_DIR_EXISTS=false'
              fi
            " 2>&1); then
            current_status="SSH_FAILED=true"
          fi

          echo "$current_status"

          if echo "$current_status" | grep -q "SSH_FAILED=true"; then
            echo "ready=false" >> $GITHUB_OUTPUT
            echo "status=ssh_failed" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "ready=true" >> $GITHUB_OUTPUT
            if echo "$current_status" | grep -q "FRONTEND_RUNNING=true\|BACKEND_RUNNING=true"; then
              echo "status=services_running" >> $GITHUB_OUTPUT
            else
              echo "status=no_services" >> $GITHUB_OUTPUT
            fi
          fi

          rm -f ~/.ssh/id_rsa

  build_images:
    name: Build and Push Images
    runs-on: ubuntu-latest
    needs: [pre_deployment, validate_environment]
    if: needs.validate_environment.outputs.environment_ready == 'true'
    permissions:
      contents: read
      packages: write
    outputs:
      frontend_image: ${{ steps.images.outputs.frontend }}
      backend_image: ${{ steps.images.outputs.backend }}
      build_success: ${{ steps.build_result.outputs.success }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate image names and tags
        id: meta
        run: |
          REPO_LOWER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          SHORT_SHA=${GITHUB_SHA:0:7}
          BUILD_TAG="${TIMESTAMP}-${SHORT_SHA}"

          FRONTEND_IMAGE="${{ env.DOCKER_REGISTRY }}/${{ github.repository_owner }}/ai-firefighter-frontend"
          BACKEND_IMAGE="${{ env.DOCKER_REGISTRY }}/${{ github.repository_owner }}/ai-firefighter-backend"
          FRONTEND_IMAGE=$(echo "$FRONTEND_IMAGE" | tr '[:upper:]' '[:lower:]')
          BACKEND_IMAGE=$(echo "$BACKEND_IMAGE" | tr '[:upper:]' '[:lower:]')

          echo "frontend-base=${FRONTEND_IMAGE}" >> $GITHUB_OUTPUT
          echo "backend-base=${BACKEND_IMAGE}" >> $GITHUB_OUTPUT
          echo "build-tag=${BUILD_TAG}" >> $GITHUB_OUTPUT

      - name: Build and push Frontend
        uses: docker/build-push-action@v5
        with:
          context: ./FO
          file: ./FO/Dockerfile
          push: true
          tags: |
            ${{ steps.meta.outputs.frontend-base }}:${{ steps.meta.outputs.build-tag }}
            ${{ steps.meta.outputs.frontend-base }}:latest
          cache-from: type=gha,scope=frontend
          cache-to: type=gha,mode=max,scope=frontend
          platforms: linux/amd64

      - name: Build and push Backend
        uses: docker/build-push-action@v5
        with:
          context: ./API
          file: ./API/Dockerfile
          push: true
          tags: |
            ${{ steps.meta.outputs.backend-base }}:${{ steps.meta.outputs.build-tag }}
            ${{ steps.meta.outputs.backend-base }}:latest
          cache-from: type=gha,scope=backend
          cache-to: type=gha,mode=max,scope=backend
          platforms: linux/amd64

      - name: Set output images
        id: images
        run: |
          echo "frontend=${{ steps.meta.outputs.frontend-base }}:${{ steps.meta.outputs.build-tag }}" >> $GITHUB_OUTPUT
          echo "backend=${{ steps.meta.outputs.backend-base }}:${{ steps.meta.outputs.build-tag }}" >> $GITHUB_OUTPUT

      - name: Mark build success
        id: build_result
        run: echo "success=true" >> $GITHUB_OUTPUT

  backup_current:
    name: Backup Current State
    runs-on: ubuntu-latest
    needs: [build_images]
    outputs:
      backup_available: ${{ steps.backup.outputs.available }}
      backup_timestamp: ${{ steps.backup.outputs.timestamp }}

    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      - name: Create comprehensive backup
        id: backup
        run: |
          BACKUP_TIME=$(date +%Y%m%d-%H%M%S)

          backup_result=$(ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
            sudo mkdir -p /opt/firefighter-backups
            sudo chown -R ${{ secrets.PRODUCTION_USER }}:${{ secrets.PRODUCTION_USER }} /opt/firefighter-backups

            cd /opt/firefighter-app 2>/dev/null || { echo 'NO_APP_DIR'; exit 0; }

            mkdir -p /opt/firefighter-backups/$BACKUP_TIME

            if [ -f docker-compose.yml ]; then
              cp docker-compose.yml /opt/firefighter-backups/$BACKUP_TIME/
              echo 'COMPOSE_BACKED_UP'
            fi

            if [ -f .env ]; then
              cp .env /opt/firefighter-backups/$BACKUP_TIME/
              echo 'ENV_BACKED_UP'
            fi

            if command -v docker >/dev/null 2>&1; then
              docker ps --format 'table {{.Image}}\t{{.Names}}\t{{.Ports}}\t{{.Status}}' > /opt/firefighter-backups/$BACKUP_TIME/current-containers.txt 2>/dev/null || echo 'No containers running' > /opt/firefighter-backups/$BACKUP_TIME/current-containers.txt
              docker-compose ps --format json > /opt/firefighter-backups/$BACKUP_TIME/container-status.json 2>/dev/null || echo '[]' > /opt/firefighter-backups/$BACKUP_TIME/container-status.json
              echo 'DOCKER_STATE_BACKED_UP'
            fi

            echo 'BACKUP_CREATED'
          " 2>&1) || echo "BACKUP_FAILED"

          if echo "$backup_result" | grep -q "BACKUP_CREATED"; then
            echo "available=true" >> $GITHUB_OUTPUT
            echo "timestamp=$BACKUP_TIME" >> $GITHUB_OUTPUT
            echo "Backup created successfully at $BACKUP_TIME"
          else
            echo "available=false" >> $GITHUB_OUTPUT
            echo "timestamp=" >> $GITHUB_OUTPUT
            echo "Backup failed or not needed: $backup_result"
          fi

          rm -f ~/.ssh/id_rsa

  prepare_deployment_files:
    name: Prepare Deployment Files
    runs-on: ubuntu-latest
    needs: [build_images]

    steps:
      - name: Create deployment files locally
        run: |
          mkdir -p deployment_files

          # Create docker-compose file
          cat > deployment_files/docker-compose.yml << 'EOF'
          version: '3.8'
          services:
            backend:
              image: ${{ needs.build_images.outputs.backend_image }}
              ports:
                - '5000:5000'
              environment:
                - DB_USERNAME=${{ secrets.DB_USERNAME }}
                - DB_PASSWORD=${{ secrets.DB_PASSWORD }}
                - DB_CLUSTER=${{ secrets.DB_CLUSTER }}
                - FLASK_ENV=production
              restart: unless-stopped
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:5000/"]
                interval: 30s
                timeout: 10s
                retries: 3

            frontend:
              image: ${{ needs.build_images.outputs.frontend_image }}
              ports:
                - '8000:8000'
              environment:
                - DB_USERNAME=${{ secrets.DB_USERNAME }}
                - DB_PASSWORD=${{ secrets.DB_PASSWORD }}
                - DB_CLUSTER=${{ secrets.DB_CLUSTER }}
                - FLASK_ENV=production
                - API_BASE_URL=http://backend:5000/api
              restart: unless-stopped
              depends_on:
                - backend
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:8000/"]
                interval: 30s
                timeout: 10s
                retries: 3
          EOF

      - name: Upload deployment files
        uses: actions/upload-artifact@v4
        with:
          name: deployment-files
          path: deployment_files/
          retention-days: 1

  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build_images, backup_current, prepare_deployment_files, validate_environment]
    outputs:
      deployment_status: ${{ steps.deploy.outputs.status }}
      frontend_working: ${{ steps.deploy.outputs.frontend_ok }}
      backend_working: ${{ steps.deploy.outputs.backend_ok }}

    steps:
      - name: Download deployment files
        uses: actions/download-artifact@v4
        with:
          name: deployment-files
          path: deployment_files

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      - name: Prepare server environment
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
            if ! command -v docker >/dev/null 2>&1; then
              curl -fsSL https://get.docker.com | sh
              usermod -aG docker ${{ secrets.PRODUCTION_USER }}
            fi

            if ! command -v docker-compose >/dev/null 2>&1; then
              curl -L \"https://github.com/docker/compose/releases/latest/download/docker-compose-\$(uname -s)-\$(uname -m)\" -o /usr/local/bin/docker-compose
              chmod +x /usr/local/bin/docker-compose
            fi

            mkdir -p /opt/firefighter-app
            chown -R ${{ secrets.PRODUCTION_USER }}:${{ secrets.PRODUCTION_USER }} /opt/firefighter-app
          "

      - name: Upload docker-compose to server
        run: |
          scp -o StrictHostKeyChecking=no deployment_files/docker-compose.yml ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }}:/opt/firefighter-app/

      - name: Purge ALL Docker services on server (requested)
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
            set -e
            echo '*** PURGING ALL DOCKER SERVICES ***'
            docker compose down --remove-orphans 2>/dev/null || docker-compose down --remove-orphans 2>/dev/null || true
            docker stop \$(docker ps -aq) 2>/dev/null || true
            docker rm \$(docker ps -aq) 2>/dev/null || true
            docker network prune -f || true
            docker volume prune -f || true
          "

      - name: Deploy (free ports, hotfix jwt if needed, start backend then frontend)
        id: deploy
        run: |
          FRONTEND_IMAGE="${{ needs.build_images.outputs.frontend_image }}"
          BACKEND_IMAGE="${{ needs.build_images.outputs.backend_image }}"

          ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
            set -e

            cd /opt/firefighter-app

            # 0) LIBERAR PUERTOS 8000/5000 y limpiar contenedores viejos
            echo 'Freeing ports 8000/5000 if in use...'
            docker ps --format '{{.ID}} {{.Ports}} {{.Names}}' | grep -E '0.0.0.0:8000->|:8000->' | awk '{print \$1}' | xargs -r docker stop || true
            docker ps --format '{{.ID}} {{.Ports}} {{.Names}}' | grep -E '0.0.0.0:5000->|:5000->' | awk '{print \$1}' | xargs -r docker stop || true
            # emergencias antiguas
            docker rm -f emergency-frontend emergency-backend 2>/dev/null || true

            # 1) Login y pull de imágenes
            echo '${{ secrets.GITHUB_TOKEN }}' | docker login ${{ env.DOCKER_REGISTRY }} -u ${{ github.actor }} --password-stdin
            docker pull $FRONTEND_IMAGE
            docker pull $BACKEND_IMAGE

            # 2) Hotfix rápido si falta PyJWT en el backend
            echo 'Checking PyJWT in backend image...'
            if ! docker run --rm $BACKEND_IMAGE python -c 'import jwt' >/dev/null 2>&1; then
              echo 'PyJWT missing. Building a small derived image with PyJWT...'
              cat > Dockerfile.jwtfix <<EOF
              FROM $BACKEND_IMAGE
              RUN python -m pip install --no-cache-dir --upgrade pip && \
                  pip install --no-cache-dir pyjwt
              EOF
              docker build -f Dockerfile.jwtfix -t backend:hotfix-jwt .
              rm -f Dockerfile.jwtfix
              # Sustituimos la imagen del backend en el docker-compose para esta ejecución
              sed -i 's|image: .*ai-firefighter-backend.*|image: backend:hotfix-jwt|' docker-compose.yml
            fi

            # 3) Desplegar en orden: primero backend, esperar OK, luego frontend
            docker-compose down --timeout 30 || true

            echo 'Starting backend only...'
            docker-compose up -d backend

            echo 'Waiting backend to be reachable on :5000 (up to 120s)...'
            for i in \$(seq 1 24); do
              if curl -s --max-time 5 http://localhost:5000/ >/dev/null 2>&1; then
                echo 'Backend is UP'
                break
              fi
              sleep 5
            done

            if ! curl -s --max-time 5 http://localhost:5000/ >/dev/null 2>&1; then
              echo 'Backend failed to start properly'
              docker logs \$(docker ps -aq --filter name=firefighter-app-backend-1 | head -1) --tail=80 || true
              echo 'FRONTEND_STATUS=FAIL'
              echo 'BACKEND_STATUS=FAIL'
              exit 1
            fi

            echo 'Starting frontend...'
            docker-compose up -d frontend

            # 4) Comprobaciones finales
            sleep 10
            FRONTEND_STATUS='FAIL'
            BACKEND_STATUS='FAIL'

            if curl -s --max-time 10 http://localhost:8000/ >/dev/null 2>&1; then
              FRONTEND_STATUS='OK'
            fi
            if curl -s --max-time 10 http://localhost:5000/ >/dev/null 2>&1; then
              BACKEND_STATUS='OK'
            fi

            echo \"FRONTEND_STATUS=\$FRONTEND_STATUS\"
            echo \"BACKEND_STATUS=\$BACKEND_STATUS\"

            if [ \"\$FRONTEND_STATUS\" = 'OK' ] && [ \"\$BACKEND_STATUS\" = 'OK' ]; then
              echo 'DEPLOYMENT_SUCCESS'
            else
              echo 'DEPLOYMENT_FAILED'
              docker-compose logs --tail=50 || true
              exit 1
            fi
          " 2>&1 | tee deploy.log

          # Parse resultados
          frontend_ok=false
          backend_ok=false
          deployment_success=false
          grep -q 'FRONTEND_STATUS=OK' deploy.log && frontend_ok=true
          grep -q 'BACKEND_STATUS=OK' deploy.log && backend_ok=true
          grep -q 'DEPLOYMENT_SUCCESS' deploy.log && deployment_success=true

          echo "status=$deployment_success" >> $GITHUB_OUTPUT
          echo "frontend_ok=$frontend_ok" >> $GITHUB_OUTPUT
          echo "backend_ok=$backend_ok" >> $GITHUB_OUTPUT

          rm -f ~/.ssh/id_rsa deploy.log

  emergency_fallback:
    name: Emergency Fallback (All Services)
    runs-on: ubuntu-latest
    needs: [deploy, validate_environment]
    if: always() && (needs.deploy.outputs.deployment_status != 'true' || needs.deploy.outputs.frontend_working != 'true' || needs.deploy.outputs.backend_working != 'true')
    outputs:
      emergency_status: ${{ steps.emergency.outputs.status }}

    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      - name: Execute emergency deployment for all services (no artifact)
        id: emergency
        run: |
          echo "🚨 EXECUTING EMERGENCY FALLBACK - ALL SERVICES 🚨"

          # Construimos nombres base de las imágenes a partir de las del build (sin tag) para probar :latest y luego :stable
          FRONTEND_BASE="${{ env.DOCKER_REGISTRY }}/$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')/ai-firefighter-frontend"
          BACKEND_BASE="${{ env.DOCKER_REGISTRY }}/$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')/ai-firefighter-backend"

          # Script local temporal que hace: login GHCR, limpia, intenta latest y si falla intenta stable
          cat > emergency-deploy.sh << 'EOF'
          #!/bin/bash
          set -e

          echo '🚨 EMERGENCY DEPLOYMENT - ALL SERVICES 🚨'

          FRONTEND_BASE="$1"
          BACKEND_BASE="$2"
          GHCR_USER="$3"
          GHCR_PAT="$4"

          # Quitar CRLF por si el archivo viene de Windows
          sed -i 's/\r$//' "$0" 2>/dev/null || true

          # Parar todo
          docker compose down --timeout 30 2>/dev/null || docker-compose down --timeout 30 2>/dev/null || true
          docker stop $(docker ps -aq) 2>/dev/null || true
          docker rm $(docker ps -aq) 2>/dev/null || true

          # Login a GHCR con credenciales explícitas
          if [ -n "$GHCR_USER" ] && [ -n "$GHCR_PAT" ]; then
            echo "$GHCR_PAT" | docker login ghcr.io -u "$GHCR_USER" --password-stdin
          else
            echo "⚠️ GHCR_USER / GHCR_PAT no configurados; continuaré y puede fallar la descarga de imágenes privadas"
          fi

          # Función: intenta pull TAG1 y si falla prueba TAG2
          pull_with_fallback () {
            local base="$1"
            local tag1="$2"
            local tag2="$3"
            if docker pull "$base:$tag1"; then
              echo "$base:$tag1"
              return 0
            fi
            if docker pull "$base:$tag2"; then
              echo "$base:$tag2"
              return 0
            fi
            return 1
          }

          echo "🔎 Intentando obtener imágenes (preferencia :latest, fallback :stable)..."
          FRONTEND_IMG=$(pull_with_fallback "$FRONTEND_BASE" "latest" "stable") || { echo "❌ No pude descargar frontend ni con :latest ni con :stable"; exit 1; }
          BACKEND_IMG=$(pull_with_fallback "$BACKEND_BASE" "latest" "stable") || { echo "❌ No pude descargar backend ni con :latest ni con :stable"; exit 1; }

          echo "✅ Usando FRONTEND=$FRONTEND_IMG"
          echo "✅ Usando BACKEND=$BACKEND_IMG"

          # Backend primero
          echo 'Starting emergency backend...'
          docker run -d --name emergency-backend -p 5000:5000 \
            -e DB_USERNAME="${DB_USERNAME}" \
            -e DB_PASSWORD="${DB_PASSWORD}" \
            -e DB_CLUSTER="${DB_CLUSTER}" \
            -e FLASK_ENV=production \
            --restart unless-stopped \
            "$BACKEND_IMG" || true

          # Frontend
          echo 'Starting emergency frontend...'
          docker run -d --name emergency-frontend -p 8000:8000 \
            -e FLASK_ENV=production \
            -e API_BASE_URL=http://localhost:5000/api \
            --restart unless-stopped \
            "$FRONTEND_IMG" || true

          # Esperar y comprobar
          sleep 30

          FRONTEND_OK=false
          BACKEND_OK=false

          if curl -s --max-time 10 http://localhost:8000/ >/dev/null; then
            echo '✅ Frontend is running'
            FRONTEND_OK=true
          else
            echo '❌ Frontend failed'
          fi

          if curl -s --max-time 10 http://localhost:5000/ >/dev/null; then
            echo '✅ Backend is running'
            BACKEND_OK=true
          else
            echo '❌ Backend failed'
          fi

          if [ "$FRONTEND_OK" = true ] && [ "$BACKEND_OK" = true ]; then
            echo '✅ EMERGENCY SUCCESS - All services running'
            exit 0
          elif [ "$FRONTEND_OK" = true ]; then
            echo '⚠️ EMERGENCY PARTIAL SUCCESS - Frontend running'
            exit 0
          else
            echo '❌ EMERGENCY FAILED'
            exit 1
          fi
          EOF
          chmod +x emergency-deploy.sh

          # Subir y ejecutar en servidor con secrets para login
          scp -o StrictHostKeyChecking=no emergency-deploy.sh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }}:/opt/firefighter-app/
          ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
            cd /opt/firefighter-app
            chmod +x emergency-deploy.sh
            sed -i 's/\r$//' emergency-deploy.sh || true
            FRONTEND_BASE='${FRONTEND_BASE}'
            BACKEND_BASE='${BACKEND_BASE}'
            GHCR_USER='${{ secrets.GHCR_USER }}'
            GHCR_PAT='${{ secrets.GHCR_PAT }}'
            DB_USERNAME='${{ secrets.DB_USERNAME }}' DB_PASSWORD='${{ secrets.DB_PASSWORD }}' DB_CLUSTER='${{ secrets.DB_CLUSTER }}' \
              ./emergency-deploy.sh \"\$FRONTEND_BASE\" \"\$BACKEND_BASE\" \"\$GHCR_USER\" \"\$GHCR_PAT\"
          " 2>&1 | tee emergency.log

          if grep -q "EMERGENCY SUCCESS" emergency.log; then
            echo "status=success" >> $GITHUB_OUTPUT
          elif grep -q "PARTIAL SUCCESS" emergency.log; then
            echo "status=partial" >> $GITHUB_OUTPUT
          else
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

          rm -f ~/.ssh/id_rsa emergency-deploy.sh emergency.log

  rollback:
    name: Rollback to Previous Version
    runs-on: ubuntu-latest
    needs: [deploy, backup_current, emergency_fallback]
    if: always() && needs.deploy.outputs.deployment_status != 'true' && needs.emergency_fallback.outputs.emergency_status != 'success' && needs.backup_current.outputs.backup_available == 'true'

    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      - name: Perform rollback
        run: |
          echo "🔄 PERFORMING ROLLBACK TO PREVIOUS VERSION"

          rollback_result=$(ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
            cd /opt/firefighter-app

            # Find most recent backup
            LATEST_BACKUP=\$(ls -t /opt/firefighter-backups/ 2>/dev/null | head -1)

            if [ -n \"\$LATEST_BACKUP\" ] && [ -d \"/opt/firefighter-backups/\$LATEST_BACKUP\" ]; then
              echo \"Rolling back to backup: \$LATEST_BACKUP\"

              # Stop current deployment
              docker-compose down --timeout 30 || docker stop \$(docker ps -aq) || true

              # Restore backup files
              [ -f \"/opt/firefighter-backups/\$LATEST_BACKUP/docker-compose.yml\" ] && \
                cp \"/opt/firefighter-backups/\$LATEST_BACKUP/docker-compose.yml\" ./
              [ -f \"/opt/firefighter-backups/\$LATEST_BACKUP/.env\" ] && \
                cp \"/opt/firefighter-backups/\$LATEST_BACKUP/.env\" ./

              # Start previous version
              docker-compose up -d

              sleep 30

              # Test rollback
              if curl -s --max-time 10 http://localhost:8000/ >/dev/null; then
                echo 'ROLLBACK_SUCCESS'
              else
                echo 'ROLLBACK_FAILED'
              fi
            else
              echo 'NO_BACKUP_AVAILABLE'
            fi
          " 2>&1)

          echo "$rollback_result"

          rm -f ~/.ssh/id_rsa

  health_check:
    name: Final Health Check
    runs-on: ubuntu-latest
    needs: [deploy, emergency_fallback, rollback]
    if: always()
    outputs:
      final_status: ${{ steps.health.outputs.status }}
      services_healthy: ${{ steps.health.outputs.services }}

    steps:
      - name: Comprehensive health check
        id: health
        run: |
          echo "🏥 FINAL HEALTH CHECK - ALL SERVICES"

          sleep 30

          # Test both services
          frontend_status="DOWN"
          backend_status="DOWN"

          for i in {1..5}; do
            if curl -s --max-time 10 "http://${{ secrets.PRODUCTION_HOST }}:8000/" >/dev/null 2>&1; then
              frontend_status="UP"
            fi

            if curl -s --max-time 10 "http://${{ secrets.PRODUCTION_HOST }}:5000/" >/dev/null 2>&1; then
              backend_status="UP"
            fi

            if [ "$frontend_status" = "UP" ] && [ "$backend_status" = "UP" ]; then
              break
            fi
            sleep 10
          done

          echo "Frontend: $frontend_status"
          echo "Backend: $backend_status"

          if [ "$frontend_status" = "UP" ] && [ "$backend_status" = "UP" ]; then
            echo "status=healthy" >> $GITHUB_OUTPUT
            echo "services=all" >> $GITHUB_OUTPUT
            echo "✅ SYSTEM IS HEALTHY - All services responding"
          elif [ "$frontend_status" = "UP" ]; then
            echo "status=degraded" >> $GITHUB_OUTPUT
            echo "services=frontend_only" >> $GITHUB_OUTPUT
            echo "⚠️ SYSTEM DEGRADED - Frontend responding, Backend down"
          else
            echo "status=critical" >> $GITHUB_OUTPUT
            echo "services=none" >> $GITHUB_OUTPUT
            echo "❌ CRITICAL - No services responding"
            exit 1
          fi

  tag_stable:
    name: Tag Stable Version
    runs-on: ubuntu-latest
    needs: [build_images, health_check]
    if: always() && needs.health_check.outputs.final_status == 'healthy' && needs.build_images.result == 'success'
    permissions:
      contents: read
      packages: write

    steps:
      - name: Login to registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Tag as stable
        run: |
          # Tag frontend as stable
          docker pull ${{ needs.build_images.outputs.frontend_image }}
          FRONTEND_BASE=$(echo "${{ needs.build_images.outputs.frontend_image }}" | cut -d':' -f1)
          docker tag ${{ needs.build_images.outputs.frontend_image }} ${FRONTEND_BASE}:stable
          docker push ${FRONTEND_BASE}:stable

          # Tag backend as stable
          docker pull ${{ needs.build_images.outputs.backend_image }}
          BACKEND_BASE=$(echo "${{ needs.build_images.outputs.backend_image }}" | cut -d':' -f1)
          docker tag ${{ needs.build_images.outputs.backend_image }} ${BACKEND_BASE}:stable
          docker push ${BACKEND_BASE}:stable

          echo "Stable versions tagged successfully for both services"

  notify:
    name: Deployment Report
    runs-on: ubuntu-latest
    needs: [pre_deployment, validate_environment, build_images, deploy, emergency_fallback, rollback, health_check, tag_stable]
    if: always()

    steps:
      - name: Generate comprehensive report
        run: |
          echo "🚒 AI FIREFIGHTER DEPLOYMENT REPORT 🚒" | tee report.md
          echo "==========================================" | tee -a report.md
          echo "Timestamp: $(date -u)" | tee -a report.md
          echo "Commit: ${{ github.sha }}" | tee -a report.md
          echo "" | tee -a report.md

          # Job Results
          echo "## Job Results:" | tee -a report.md
          echo "- Pre-deployment: ${{ needs.pre_deployment.result }}" | tee -a report.md
          echo "- Environment Validation: ${{ needs.validate_environment.result }}" | tee -a report.md
          echo "- Build Images: ${{ needs.build_images.result }}" | tee -a report.md
          echo "- Deploy: ${{ needs.deploy.result }}" | tee -a report.md
          echo "- Emergency Fallback: ${{ needs.emergency_fallback.result }}" | tee -a report.md
          echo "- Rollback: ${{ needs.rollback.result }}" | tee -a report.md
          echo "- Health Check: ${{ needs.health_check.result }}" | tee -a report.md
          echo "- Tag Stable: ${{ needs.tag_stable.result }}" | tee -a report.md
          echo "" | tee -a report.md

          # Final Status
          if [ "${{ needs.health_check.outputs.final_status }}" = "healthy" ]; then
            echo "## ✅ DEPLOYMENT SUCCESSFUL - ALL SERVICES" | tee -a report.md
            echo "Frontend: http://167.71.42.17:8000" | tee -a report.md
            echo "Backend: http://167.71.42.17:5000" | tee -a report.md
          elif [ "${{ needs.health_check.outputs.final_status }}" = "degraded" ]; then
            echo "## ⚠️ DEPLOYMENT PARTIAL SUCCESS" | tee -a report.md
            echo "Frontend: http://167.71.42.17:8000 ✅" | tee -a report.md
            echo "Backend: http://167.71.42.17:5000 ❌" | tee -a report.md
          else
            echo "## ❌ DEPLOYMENT FAILED" | tee -a report.md
            echo "All deployment strategies failed" | tee -a report.md
          fi

          echo "" | tee -a report.md
          echo "## Deployment Strategy Used:" | tee -a report.md
          if [ "${{ needs.deploy.result }}" = "success" ]; then
            echo "- ✅ Normal deployment" | tee -a report.md
          elif [ "${{ needs.emergency_fallback.result }}" = "success" ]; then
            echo "- 🚨 Emergency deployment" | tee -a report.md
          elif [ "${{ needs.rollback.result }}" = "success" ]; then
            echo "- 🔄 Rollback deployment" | tee -a report.md
          fi

      - name: Upload report
        uses: actions/upload-artifact@v4
        with:
          name: deployment-report-${{ github.run_id }}
          path: report.md
          retention-days: 30
