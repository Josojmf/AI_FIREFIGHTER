name: CD Pipeline - Ultra Robust with Emergency Fallback

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment'
        required: false
        default: false
        type: boolean
      emergency_mode:
        description: 'Deploy in emergency mode (all services)'
        required: false
        default: false
        type: boolean

env:
  DOCKER_REGISTRY: ghcr.io
  DEPLOYMENT_TIMEOUT: 180
  MAX_DEPLOYMENT_ATTEMPTS: 2

jobs:
  pre_deployment:
    name: Pre-deployment Safety Check
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      deploy_mode: ${{ steps.check.outputs.deploy_mode }}
    
    steps:
      - name: Determine deployment strategy
        id: check
        run: |
          should_deploy="true"
          deploy_mode="normal"
          
          if [ "${{ github.event.inputs.emergency_mode }}" = "true" ]; then
            echo "Emergency deployment mode requested"
            deploy_mode="emergency"
          elif [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then
            echo "Force deployment requested"
            deploy_mode="force"
          else
            echo "Normal deployment mode"
            deploy_mode="normal"
          fi
          
          echo "should_deploy=$should_deploy" >> $GITHUB_OUTPUT
          echo "deploy_mode=$deploy_mode" >> $GITHUB_OUTPUT

  validate_environment:
    name: Validate Production Environment
    runs-on: ubuntu-latest
    needs: pre_deployment
    outputs:
      environment_ready: ${{ steps.validate.outputs.ready }}
      current_status: ${{ steps.validate.outputs.status }}
    
    steps:
      - name: Check required secrets
        run: |
          missing=()
          
          [ -z "${{ secrets.PRODUCTION_SSH_KEY }}" ] && missing+=("PRODUCTION_SSH_KEY")
          [ -z "${{ secrets.PRODUCTION_HOST }}" ] && missing+=("PRODUCTION_HOST")
          [ -z "${{ secrets.PRODUCTION_USER }}" ] && missing+=("PRODUCTION_USER")
          [ -z "${{ secrets.DB_USERNAME }}" ] && missing+=("DB_USERNAME")
          [ -z "${{ secrets.DB_PASSWORD }}" ] && missing+=("DB_PASSWORD")
          [ -z "${{ secrets.DB_CLUSTER }}" ] && missing+=("DB_CLUSTER")
          
          if [ ${#missing[@]} -ne 0 ]; then
            echo "Missing secrets: ${missing[*]}"
            exit 1
          fi
          
          echo "All secrets configured"

      - name: Validate production server
        id: validate
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts
          
          current_status=$(ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 \
            ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
            echo 'Server accessible'
            
            if curl -s --max-time 5 http://localhost:8000/ >/dev/null 2>&1; then
              echo 'CURRENT_SERVICE_RUNNING=true'
            else
              echo 'CURRENT_SERVICE_RUNNING=false'
            fi
            
            if command -v docker >/dev/null 2>&1; then
              echo 'DOCKER_AVAILABLE=true'
            else
              echo 'DOCKER_AVAILABLE=false'
            fi
            
            if [ -d /opt/firefighter-app ]; then
              echo 'DEPLOY_DIR_EXISTS=true'
            else
              echo 'DEPLOY_DIR_EXISTS=false'
            fi
          " 2>&1) || echo "SSH_FAILED=true"
          
          echo "$current_status"
          
          if echo "$current_status" | grep -q "SSH_FAILED=true"; then
            echo "ready=false" >> $GITHUB_OUTPUT
            echo "status=ssh_failed" >> $GITHUB_OUTPUT
            exit 1
          elif echo "$current_status" | grep -q "CURRENT_SERVICE_RUNNING=true"; then
            echo "ready=true" >> $GITHUB_OUTPUT
            echo "status=service_running" >> $GITHUB_OUTPUT
          else
            echo "ready=true" >> $GITHUB_OUTPUT  
            echo "status=no_service" >> $GITHUB_OUTPUT
          fi
          
          rm -f ~/.ssh/id_rsa

  build_images:
    name: Build and Push Images
    runs-on: ubuntu-latest
    needs: [pre_deployment, validate_environment]
    if: needs.validate_environment.outputs.environment_ready == 'true'
    permissions:
      contents: read
      packages: write
    outputs:
      frontend_image: ${{ steps.images.outputs.frontend }}
      backend_image: ${{ steps.images.outputs.backend }}
      build_success: ${{ steps.build_result.outputs.success }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate image names and tags
        id: meta
        run: |
          REPO_LOWER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          SHORT_SHA=${GITHUB_SHA:0:7}
          BUILD_TAG="${TIMESTAMP}-${SHORT_SHA}"
          
          FRONTEND_IMAGE="${{ env.DOCKER_REGISTRY }}/${REPO_LOWER}/ai-firefighter-frontend"
          BACKEND_IMAGE="${{ env.DOCKER_REGISTRY }}/${REPO_LOWER}/ai-firefighter-backend"
          
          echo "frontend-base=${FRONTEND_IMAGE}" >> $GITHUB_OUTPUT
          echo "backend-base=${BACKEND_IMAGE}" >> $GITHUB_OUTPUT
          echo "build-tag=${BUILD_TAG}" >> $GITHUB_OUTPUT

      - name: Build and push Frontend
        uses: docker/build-push-action@v5
        with:
          context: ./FO
          file: ./FO/Dockerfile
          push: true
          tags: |
            ${{ steps.meta.outputs.frontend-base }}:${{ steps.meta.outputs.build-tag }}
            ${{ steps.meta.outputs.frontend-base }}:latest
          cache-from: type=gha,scope=frontend
          cache-to: type=gha,mode=max,scope=frontend
          platforms: linux/amd64

      - name: Build and push Backend
        uses: docker/build-push-action@v5
        with:
          context: ./API
          file: ./API/Dockerfile
          push: true
          tags: |
            ${{ steps.meta.outputs.backend-base }}:${{ steps.meta.outputs.build-tag }}
            ${{ steps.meta.outputs.backend-base }}:latest
          cache-from: type=gha,scope=backend
          cache-to: type=gha,mode=max,scope=backend
          platforms: linux/amd64

      - name: Set output images
        id: images
        run: |
          echo "frontend=${{ steps.meta.outputs.frontend-base }}:${{ steps.meta.outputs.build-tag }}" >> $GITHUB_OUTPUT
          echo "backend=${{ steps.meta.outputs.backend-base }}:${{ steps.meta.outputs.build-tag }}" >> $GITHUB_OUTPUT

      - name: Mark build success
        id: build_result
        run: echo "success=true" >> $GITHUB_OUTPUT

  backup_current:
    name: Backup Current State
    runs-on: ubuntu-latest
    needs: [build_images]
    outputs:
      backup_available: ${{ steps.backup.outputs.available }}
      backup_timestamp: ${{ steps.backup.outputs.timestamp }}
    
    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      - name: Create backup
        id: backup
        run: |
          BACKUP_TIME=$(date +%Y%m%d-%H%M%S)
          
          backup_result=$(ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
            sudo mkdir -p /opt/firefighter-backups
            sudo chown -R ${{ secrets.PRODUCTION_USER }}:${{ secrets.PRODUCTION_USER }} /opt/firefighter-backups
            
            cd /opt/firefighter-app 2>/dev/null || { echo 'NO_APP_DIR'; exit 0; }
            
            if [ -f docker-compose.yml ] || [ -f .env ]; then
              mkdir -p /opt/firefighter-backups/$BACKUP_TIME
              [ -f docker-compose.yml ] && cp docker-compose.yml /opt/firefighter-backups/$BACKUP_TIME/
              [ -f .env ] && cp .env /opt/firefighter-backups/$BACKUP_TIME/
              docker-compose ps --format json > /opt/firefighter-backups/$BACKUP_TIME/container-status.json 2>/dev/null || echo '[]' > /opt/firefighter-backups/$BACKUP_TIME/container-status.json
              
              # Save current running images
              docker ps --format "{{.Image}}" > /opt/firefighter-backups/$BACKUP_TIME/running-images.txt 2>/dev/null || true
              echo 'BACKUP_CREATED'
            else
              echo 'NO_BACKUP_NEEDED'
            fi
          " 2>&1) || echo "BACKUP_FAILED"
          
          if echo "$backup_result" | grep -q "BACKUP_CREATED"; then
            echo "available=true" >> $GITHUB_OUTPUT
            echo "timestamp=$BACKUP_TIME" >> $GITHUB_OUTPUT
            echo "Backup created successfully: $BACKUP_TIME"
          else
            echo "available=false" >> $GITHUB_OUTPUT
            echo "timestamp=none" >> $GITHUB_OUTPUT
            echo "No backup needed or backup failed: $backup_result"
          fi
          
          rm -f ~/.ssh/id_rsa

  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build_images, backup_current, validate_environment]
    outputs:
      deployment_status: ${{ steps.deploy.outputs.status }}
      frontend_working: ${{ steps.deploy.outputs.frontend_ok }}
      backend_working: ${{ steps.deploy.outputs.backend_ok }}
    
    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      - name: Prepare server environment
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
            if ! command -v docker >/dev/null 2>&1; then
              curl -fsSL https://get.docker.com | sh
              usermod -aG docker ${{ secrets.PRODUCTION_USER }}
            fi
            
            if ! command -v docker-compose >/dev/null 2>&1; then
              curl -L \"https://github.com/docker/compose/releases/latest/download/docker-compose-\$(uname -s)-\$(uname -m)\" -o /usr/local/bin/docker-compose
              chmod +x /usr/local/bin/docker-compose
            fi
            
            mkdir -p /opt/firefighter-app
            chown -R ${{ secrets.PRODUCTION_USER }}:${{ secrets.PRODUCTION_USER }} /opt/firefighter-app
          "

      - name: Create emergency deployment script (ALL SERVICES)
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
            cat > /opt/firefighter-app/emergency-deploy-all.sh << 'EMERGENCY_SCRIPT'
            #!/bin/bash
            echo '🚨 EMERGENCY DEPLOYMENT - ALL SERVICES 🚨'
            
            # Stop everything
            docker-compose down --timeout 30 2>/dev/null || true
            docker stop \$(docker ps -aq) 2>/dev/null || true
            docker rm \$(docker ps -aq) 2>/dev/null || true
            
            # Create minimal docker-compose for emergency
            cat > /opt/firefighter-app/docker-compose-emergency.yml << 'COMPOSE_EOF'
            version: '3.8'
            services:
              frontend:
                image: ghcr.io/josojmf/ai-firefighter-frontend:stable
                ports:
                  - '8000:8000'
                environment:
                  - FLASK_ENV=production
                  - API_BASE_URL=http://backend:5000/api
                restart: unless-stopped
                depends_on:
                  - backend
                healthcheck:
                  test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8000/health\"]
                  interval: 30s
                  timeout: 10s
                  retries: 3

              backend:
                image: ghcr.io/josojmf/ai-firefighter-backend:stable
                ports:
                  - '5000:5000'
                environment:
                  - DB_USERNAME=\${DB_USERNAME}
                  - DB_PASSWORD=\${DB_PASSWORD}
                  - DB_CLUSTER=\${DB_CLUSTER}
                  - FLASK_ENV=production
                restart: unless-stopped
                healthcheck:
                  test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:5000/health\"]
                  interval: 30s
                  timeout: 10s
                  retries: 3
            COMPOSE_EOF
            
            # Try stable images first, then fallback to known working versions
            echo 'Pulling emergency images...'
            docker pull ghcr.io/josojmf/ai-firefighter-frontend:stable || \\
            docker pull ghcr.io/josojmf/ai-firefighter-frontend:latest || \\
            docker pull ghcr.io/josojmf/ai-firefighter-frontend:20250922-180353-8984cd5
            
            docker pull ghcr.io/josojmf/ai-firefighter-backend:stable || \\
            docker pull ghcr.io/josojmf/ai-firefighter-backend:latest || \\
            docker pull ghcr.io/josojmf/ai-firefighter-backend:20250922-180353-8984cd5
            
            # Start emergency deployment
            echo 'Starting emergency services...'
            cd /opt/firefighter-app
            DB_USERNAME=\$1 DB_PASSWORD=\$2 DB_CLUSTER=\$3 docker-compose -f docker-compose-emergency.yml up -d
            
            # Wait and check health
            sleep 30
            
            echo 'Checking service health...'
            frontend_healthy=false
            backend_healthy=false
            
            # Check frontend
            if curl -s --max-time 10 http://localhost:8000/health >/dev/null 2>&1; then
              frontend_healthy=true
              echo '✅ Frontend is healthy'
            else
              echo '⚠️ Frontend health check failed, but continuing...'
            fi
            
            # Check backend
            if curl -s --max-time 10 http://localhost:5000/health >/dev/null 2>&1; then
              backend_healthy=true
              echo '✅ Backend is healthy'
            else
              echo '⚠️ Backend health check failed, but continuing...'
            fi
            
            # At least frontend should be working for basic functionality
            if curl -s --max-time 10 http://localhost:8000/ >/dev/null; then
              echo '✅ EMERGENCY DEPLOYMENT SUCCESSFUL - Services are running'
              echo '🌐 Frontend: http://167.71.42.17:8000'
              echo '🔧 Backend: http://167.71.42.17:5000'
              exit 0
            else
              echo '❌ EMERGENCY DEPLOYMENT FAILED - No services responding'
              exit 1
            fi
            EMERGENCY_SCRIPT
            
            chmod +x /opt/firefighter-app/emergency-deploy-all.sh
          "

      - name: Attempt normal deployment
        id: deploy
        run: |
          deployment_success="false"
          frontend_ok="false"
          backend_ok="false"
          
          for attempt in 1 2; do
            echo "Deployment attempt $attempt/2..."
            
            deployment_result=$(ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
              cd /opt/firefighter-app
              
              # Create docker-compose configuration
              cat > docker-compose.yml << 'COMPOSE_EOF'
              version: '3.8'
              services:
                frontend:
                  image: ${{ needs.build_images.outputs.frontend_image }}
                  ports:
                    - '8000:8000'
                  environment:
                    - DB_USERNAME=${{ secrets.DB_USERNAME }}
                    - DB_PASSWORD=${{ secrets.DB_PASSWORD }}
                    - DB_CLUSTER=${{ secrets.DB_CLUSTER }}
                    - FLASK_ENV=production
                    - API_BASE_URL=http://backend:5000/api
                  restart: unless-stopped
                  depends_on:
                    - backend
                  healthcheck:
                    test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8000/health\"]
                    interval: 30s
                    timeout: 10s
                    retries: 3

                backend:
                  image: ${{ needs.build_images.outputs.backend_image }}
                  ports:
                    - '5000:5000'
                  environment:
                    - DB_USERNAME=${{ secrets.DB_USERNAME }}
                    - DB_PASSWORD=${{ secrets.DB_PASSWORD }}
                    - DB_CLUSTER=${{ secrets.DB_CLUSTER }}
                    - FLASK_ENV=production
                  restart: unless-stopped
                  healthcheck:
                    test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:5000/health\"]
                    interval: 30s
                    timeout: 10s
                    retries: 3
              COMPOSE_EOF
              
              # Login to registry
              echo '${{ secrets.GITHUB_TOKEN }}' | docker login ${{ env.DOCKER_REGISTRY }} -u ${{ github.actor }} --password-stdin
              
              # Pull images
              docker pull ${{ needs.build_images.outputs.frontend_image }}
              docker pull ${{ needs.build_images.outputs.backend_image }}
              
              # Deploy
              docker-compose down --timeout 30 || true
              docker-compose up -d
              
              # Wait and test
              sleep 60
              
              # Test services with health checks
              frontend_status='FAIL'
              backend_status='FAIL'
              
              if curl -s --max-time 10 http://localhost:8000/health >/dev/null 2>&1; then
                frontend_status='OK'
              fi
              
              if curl -s --max-time 10 http://localhost:5000/health >/dev/null 2>&1; then
                backend_status='OK'
              fi
              
              echo \"FRONTEND_STATUS=\$frontend_status\"
              echo \"BACKEND_STATUS=\$backend_status\"
              
              if [ \"\$frontend_status\" = 'OK' ] && [ \"\$backend_status\" = 'OK' ]; then
                echo 'DEPLOYMENT_SUCCESS'
              else
                echo 'DEPLOYMENT_FAILED'
                docker-compose logs --tail=20
              fi
            " 2>&1) || echo "DEPLOYMENT_ATTEMPT_FAILED"
            
            echo "$deployment_result"
            
            if echo "$deployment_result" | grep -q "FRONTEND_STATUS=OK"; then
              frontend_ok="true"
            fi
            
            if echo "$deployment_result" | grep -q "BACKEND_STATUS=OK"; then
              backend_ok="true"
            fi
            
            if echo "$deployment_result" | grep -q "DEPLOYMENT_SUCCESS"; then
              deployment_success="true"
              break
            fi
            
            echo "Attempt $attempt failed, will retry..." 
            sleep 30
          done
          
          echo "status=$deployment_success" >> $GITHUB_OUTPUT
          echo "frontend_ok=$frontend_ok" >> $GITHUB_OUTPUT
          echo "backend_ok=$backend_ok" >> $GITHUB_OUTPUT
          
          rm -f ~/.ssh/id_rsa

  emergency_fallback:
    name: Emergency Fallback (All Services)
    runs-on: ubuntu-latest
    needs: [deploy, validate_environment]
    if: always() && (needs.deploy.outputs.deployment_status != 'true' || needs.deploy.outputs.frontend_working != 'true')
    
    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      - name: Execute emergency deployment for all services
        run: |
          echo "🚨 EXECUTING EMERGENCY FALLBACK - ALL SERVICES 🚨"
          
          emergency_result=$(ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
            cd /opt/firefighter-app
            
            # Execute emergency script for all services
            if [ -f emergency-deploy-all.sh ]; then
              ./emergency-deploy-all.sh '${{ secrets.DB_USERNAME }}' '${{ secrets.DB_PASSWORD }}' '${{ secrets.DB_CLUSTER }}'
            else
              echo 'Emergency script not found, executing inline emergency deployment'
              
              # Stop everything
              docker-compose down --timeout 30 2>/dev/null || true
              docker stop \$(docker ps -aq) 2>/dev/null || true
              docker rm \$(docker ps -aq) 2>/dev/null || true
              
              # Deploy both services
              echo 'Starting emergency frontend...'
              docker run -d --name emergency-frontend -p 8000:8000 \\
                -e FLASK_ENV=production \\
                -e API_BASE_URL=http://167.71.42.17:5000/api \\
                --restart unless-stopped \\
                ghcr.io/josojmf/ai-firefighter-frontend:stable || \\
              docker run -d --name emergency-frontend -p 8000:8000 \\
                -e FLASK_ENV=production \\
                --restart unless-stopped \\
                ghcr.io/josojmf/ai-firefighter-frontend:latest
              
              echo 'Starting emergency backend...'
              docker run -d --name emergency-backend -p 5000:5000 \\
                -e DB_USERNAME=${{ secrets.DB_USERNAME }} \\
                -e DB_PASSWORD=${{ secrets.DB_PASSWORD }} \\
                -e DB_CLUSTER=${{ secrets.DB_CLUSTER }} \\
                -e FLASK_ENV=production \\
                --restart unless-stopped \\
                ghcr.io/josojmf/ai-firefighter-backend:stable || \\
              docker run -d --name emergency-backend -p 5000:5000 \\
                -e DB_USERNAME=${{ secrets.DB_USERNAME }} \\
                -e DB_PASSWORD=${{ secrets.DB_PASSWORD }} \\
                -e DB_CLUSTER=${{ secrets.DB_CLUSTER }} \\
                -e FLASK_ENV=production \\
                --restart unless-stopped \\
                ghcr.io/josojmf/ai-firefighter-backend:latest
              
              sleep 30
              
              # Check both services
              frontend_up=false
              backend_up=false
              
              if curl -s --max-time 10 http://localhost:8000/ >/dev/null; then
                frontend_up=true
                echo '✅ Emergency frontend is running'
              fi
              
              if curl -s --max-time 10 http://localhost:5000/ >/dev/null; then
                backend_up=true
                echo '✅ Emergency backend is running'
              fi
              
              if [ \"\$frontend_up\" = true ] && [ \"\$backend_up\" = true ]; then
                echo 'EMERGENCY_SUCCESS_ALL'
              elif [ \"\$frontend_up\" = true ]; then
                echo 'EMERGENCY_SUCCESS_FRONTEND_ONLY'
              else
                echo 'EMERGENCY_FAILED'
                exit 1
              fi
            fi
          " 2>&1)
          
          echo "$emergency_result"
          
          if echo "$emergency_result" | grep -q "EMERGENCY_SUCCESS_ALL"; then
            echo "✅ Emergency deployment successful - All services running"
          elif echo "$emergency_result" | grep -q "EMERGENCY_SUCCESS_FRONTEND_ONLY"; then
            echo "⚠️ Emergency deployment partially successful - Frontend running, Backend failed"
          else
            echo "❌ Emergency deployment failed"
            exit 1
          fi
          
          rm -f ~/.ssh/id_rsa

  rollback:
    name: Rollback to Previous Version  
    runs-on: ubuntu-latest
    needs: [deploy, backup_current, emergency_fallback]
    if: always() && needs.deploy.outputs.deployment_status != 'true' && needs.emergency_fallback.result != 'success' && needs.backup_current.outputs.backup_available == 'true'
    
    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      - name: Perform rollback
        run: |
          echo "🔄 PERFORMING ROLLBACK TO PREVIOUS VERSION"
          
          rollback_result=$(ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
            cd /opt/firefighter-app
            
            # Find most recent backup
            LATEST_BACKUP=\$(ls -t /opt/firefighter-backups/ 2>/dev/null | head -1)
            
            if [ -n \"\$LATEST_BACKUP\" ] && [ -d \"/opt/firefighter-backups/\$LATEST_BACKUP\" ]; then
              echo \"Rolling back to backup: \$LATEST_BACKUP\"
              
              # Stop current deployment
              docker-compose down --timeout 30 || docker stop \$(docker ps -aq) || true
              
              # Restore backup files
              [ -f \"/opt/firefighter-backups/\$LATEST_BACKUP/docker-compose.yml\" ] && \\
                cp \"/opt/firefighter-backups/\$LATEST_BACKUP/docker-compose.yml\" ./
              [ -f \"/opt/firefighter-backups/\$LATEST_BACKUP/.env\" ] && \\
                cp \"/opt/firefighter-backups/\$LATEST_BACKUP/.env\" ./
              
              # Start previous version
              docker-compose up -d
              
              sleep 30
              
              # Test rollback
              frontend_ok=false
              backend_ok=false
              
              if curl -s --max-time 10 http://localhost:8000/ >/dev/null; then
                frontend_ok=true
              fi
              
              if curl -s --max-time 10 http://localhost:5000/ >/dev/null; then
                backend_ok=true
              fi
              
              if [ \"\$frontend_ok\" = true ] && [ \"\$backend_ok\" = true ]; then
                echo 'ROLLBACK_SUCCESS_ALL'
              elif [ \"\$frontend_ok\" = true ]; then
                echo 'ROLLBACK_SUCCESS_FRONTEND_ONLY'
              else
                echo 'ROLLBACK_FAILED'
                # Last resort - emergency deployment
                /opt/firefighter-app/emergency-deploy-all.sh '${{ secrets.DB_USERNAME }}' '${{ secrets.DB_PASSWORD }}' '${{ secrets.DB_CLUSTER }}'
              fi
            else
              echo 'NO_BACKUP_AVAILABLE - executing emergency deployment'
              /opt/firefighter-app/emergency-deploy-all.sh '${{ secrets.DB_USERNAME }}' '${{ secrets.DB_PASSWORD }}' '${{ secrets.DB_CLUSTER }}'
            fi
          " 2>&1)
          
          echo "$rollback_result"
          
          rm -f ~/.ssh/id_rsa

  health_check:
    name: Final Health Check
    runs-on: ubuntu-latest
    needs: [deploy, emergency_fallback, rollback]
    if: always()
    outputs:
      final_status: ${{ steps.health.outputs.status }}
      services_healthy: ${{ steps.health.outputs.services }}
    
    steps:
      - name: Comprehensive health check
        id: health
        run: |
          echo "🏥 FINAL HEALTH CHECK - ALL SERVICES"
          
          sleep 30
          
          # Test both services
          frontend_status="DOWN"
          backend_status="DOWN"
          
          for i in {1..5}; do
            if curl -s --max-time 10 "http://${{ secrets.PRODUCTION_HOST }}:8000/" >/dev/null 2>&1; then
              frontend_status="UP"
            fi
            
            if curl -s --max-time 10 "http://${{ secrets.PRODUCTION_HOST }}:5000/" >/dev/null 2>&1; then
              backend_status="UP"
            fi
            
            if [ "$frontend_status" = "UP" ] && [ "$backend_status" = "UP" ]; then
              break
            fi
            sleep 10
          done
          
          echo "Frontend: $frontend_status"
          echo "Backend: $backend_status"
          
          if [ "$frontend_status" = "UP" ] && [ "$backend_status" = "UP" ]; then
            echo "status=healthy" >> $GITHUB_OUTPUT
            echo "services=all" >> $GITHUB_OUTPUT
            echo "✅ SYSTEM IS HEALTHY - All services responding"
          elif [ "$frontend_status" = "UP" ]; then
            echo "status=degraded" >> $GITHUB_OUTPUT
            echo "services=frontend_only" >> $GITHUB_OUTPUT
            echo "⚠️ SYSTEM DEGRADED - Frontend responding, Backend down"
          else
            echo "status=critical" >> $GITHUB_OUTPUT
            echo "services=none" >> $GITHUB_OUTPUT
            echo "❌ CRITICAL - No services responding"
            exit 1
          fi

  tag_stable:
    name: Tag Stable Version
    runs-on: ubuntu-latest
    needs: [build_images, health_check]
    if: always() && needs.health_check.outputs.final_status == 'healthy' && needs.build_images.result == 'success'
    permissions:
      contents: read
      packages: write
    
    steps:
      - name: Login to registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Tag as stable
        run: |
          # Tag frontend as stable
          docker pull ${{ needs.build_images.outputs.frontend_image }}
          FRONTEND_BASE=$(echo "${{ needs.build_images.outputs.frontend_image }}" | cut -d':' -f1)
          docker tag ${{ needs.build_images.outputs.frontend_image }} ${FRONTEND_BASE}:stable
          docker push ${FRONTEND_BASE}:stable
          
          # Tag backend as stable
          docker pull ${{ needs.build_images.outputs.backend_image }}
          BACKEND_BASE=$(echo "${{ needs.build_images.outputs.backend_image }}" | cut -d':' -f1)
          docker tag ${{ needs.build_images.outputs.backend_image }} ${BACKEND_BASE}:stable
          docker push ${BACKEND_BASE}:stable
          
          echo "Stable versions tagged successfully for both services"

  notify:
    name: Deployment Report
    runs-on: ubuntu-latest
    needs: [pre_deployment, validate_environment, build_images, deploy, emergency_fallback, rollback, health_check, tag_stable]
    if: always()
    
    steps:
      - name: Generate comprehensive report
        run: |
          echo "🚒 AI FIREFIGHTER DEPLOYMENT REPORT 🚒" | tee report.md
          echo "==========================================" | tee -a report.md
          echo "Timestamp: $(date -u)" | tee -a report.md
          echo "Commit: ${{ github.sha }}" | tee -a report.md
          echo "" | tee -a report.md
          
          # Job Results
          echo "## Job Results:" | tee -a report.md
          echo "- Pre-deployment: ${{ needs.pre_deployment.result }}" | tee -a report.md
          echo "- Environment Validation: ${{ needs.validate_environment.result }}" | tee -a report.md
          echo "- Build Images: ${{ needs.build_images.result }}" | tee -a report.md
          echo "- Deploy: ${{ needs.deploy.result }}" | tee -a report.md
          echo "- Emergency Fallback: ${{ needs.emergency_fallback.result }}" | tee -a report.md
          echo "- Rollback: ${{ needs.rollback.result }}" | tee -a report.md
          echo "- Health Check: ${{ needs.health_check.result }}" | tee -a report.md
          echo "- Tag Stable: ${{ needs.tag_stable.result }}" | tee -a report.md
          echo "" | tee -a report.md
          
          # Final Status
          if [ "${{ needs.health_check.outputs.final_status }}" = "healthy" ]; then
            echo "## ✅ DEPLOYMENT SUCCESSFUL - ALL SERVICES" | tee -a report.md
            echo "Frontend: http://167.71.42.17:8000" | tee -a report.md
            echo "Backend: http://167.71.42.17:5000" | tee -a report.md
          elif [ "${{ needs.health_check.outputs.final_status }}" = "degraded" ]; then
            echo "## ⚠️ DEPLOYMENT PARTIAL SUCCESS" | tee -a report.md
            echo "Frontend: http://167.71.42.17:8000 ✅" | tee -a report.md
            echo "Backend: http://167.71.42.17:5000 ❌" | tee -a report.md
          else
            echo "## ❌ DEPLOYMENT FAILED" | tee -a report.md
            echo "All deployment strategies failed" | tee -a report.md
          fi
          
          echo "" | tee -a report.md
          echo "## Deployment Strategy Used:" | tee -a report.md
          if [ "${{ needs.deploy.result }}" = "success" ]; then
            echo "- ✅ Normal deployment" | tee -a report.md
          elif [ "${{ needs.emergency_fallback.result }}" = "success" ]; then
            echo "- 🚨 Emergency deployment" | tee -a report.md
          elif [ "${{ needs.rollback.result }}" = "success" ]; then
            echo "- 🔄 Rollback deployment" | tee -a report.md
          fi

      - name: Upload report
        uses: actions/upload-artifact@v4
        with:
          name: deployment-report-${{ github.run_id }}
          path: report.md
          retention-days: 30