name: CD Pipeline - Ultra Robust with Emergency Fallback

"on":
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment'
        required: false
        default: false
        type: boolean
      emergency_mode:
        description: 'Deploy in emergency mode (all services)'
        required: false
        default: false
        type: boolean

env:
  DOCKER_REGISTRY: ghcr.io
  DEPLOYMENT_TIMEOUT: 180
  MAX_DEPLOYMENT_ATTEMPTS: 2

jobs:
  pre_deployment:
    name: Pre-deployment Safety Check
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      deploy_mode: ${{ steps.check.outputs.deploy_mode }}

    steps:
      - name: Determine deployment strategy
        id: check
        run: |
          should_deploy="true"
          deploy_mode="normal"

          if [ "${{ github.event.inputs.emergency_mode }}" = "true" ]; then
            echo "Emergency deployment mode requested"
            deploy_mode="emergency"
          elif [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then
            echo "Force deployment requested"
            deploy_mode="force"
          else
            echo "Normal deployment mode"
            deploy_mode="normal"
          fi

          echo "should_deploy=$should_deploy" >> $GITHUB_OUTPUT
          echo "deploy_mode=$deploy_mode" >> $GITHUB_OUTPUT

  validate_environment:
    name: Validate Production Environment
    runs-on: ubuntu-latest
    needs: pre_deployment
    outputs:
      environment_ready: ${{ steps.validate.outputs.ready }}
      current_status: ${{ steps.validate.outputs.status }}

    steps:
      - name: Check required secrets
        run: |
          missing=()

          [ -z "${{ secrets.PRODUCTION_SSH_KEY }}" ] && missing+=("PRODUCTION_SSH_KEY")
          [ -z "${{ secrets.PRODUCTION_HOST }}" ] && missing+=("PRODUCTION_HOST")
          [ -z "${{ secrets.PRODUCTION_USER }}" ] && missing+=("PRODUCTION_USER")
          [ -z "${{ secrets.DB_USERNAME }}" ] && missing+=("DB_USERNAME")
          [ -z "${{ secrets.DB_PASSWORD }}" ] && missing+=("DB_PASSWORD")
          [ -z "${{ secrets.DB_CLUSTER }}" ] && missing+=("DB_CLUSTER")

          if [ ${#missing[@]} -ne 0 ]; then
            echo "Missing secrets: ${missing[*]}"
            exit 1
          fi

          echo "All secrets configured"

      - name: Validate production server
        id: validate
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

          if ! current_status=$(ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 \
            ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
              echo 'Server accessible'

              if curl -s --max-time 5 http://localhost:8000/ >/dev/null 2>&1; then
                echo 'FRONTEND_RUNNING=true'
              else
                echo 'FRONTEND_RUNNING=false'
              fi

              if curl -s --max-time 5 http://localhost:5000/ >/dev/null 2>&1; then
                echo 'BACKEND_RUNNING=true'
              else
                echo 'BACKEND_RUNNING=false'
              fi

              if command -v docker >/dev/null 2>&1; then
                echo 'DOCKER_AVAILABLE=true'
              else
                echo 'DOCKER_AVAILABLE=false'
              fi

              if [ -d /opt/firefighter-app ]; then
                echo 'DEPLOY_DIR_EXISTS=true'
              else
                echo 'DEPLOY_DIR_EXISTS=false'
              fi
            " 2>&1); then
            current_status="SSH_FAILED=true"
          fi

          echo "$current_status"

          if echo "$current_status" | grep -q "SSH_FAILED=true"; then
            echo "ready=false" >> $GITHUB_OUTPUT
            echo "status=ssh_failed" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "ready=true" >> $GITHUB_OUTPUT
            if echo "$current_status" | grep -q "FRONTEND_RUNNING=true\|BACKEND_RUNNING=true"; then
              echo "status=services_running" >> $GITHUB_OUTPUT
            else
              echo "status=no_services" >> $GITHUB_OUTPUT
            fi
          fi

          rm -f ~/.ssh/id_rsa

  build_images:
    name: Build and Push Images
    runs-on: ubuntu-latest
    needs: [pre_deployment, validate_environment]
    if: needs.validate_environment.outputs.environment_ready == 'true'
    permissions:
      contents: read
      packages: write
    outputs:
      frontend_image: ${{ steps.images.outputs.frontend }}
      backend_image: ${{ steps.images.outputs.backend }}
      build_success: ${{ steps.build_result.outputs.success }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate image names and tags
        id: meta
        run: |
          REPO_LOWER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          SHORT_SHA=${GITHUB_SHA:0:7}
          BUILD_TAG="${TIMESTAMP}-${SHORT_SHA}"

          FRONTEND_IMAGE="${{ env.DOCKER_REGISTRY }}/${REPO_LOWER}/ai-firefighter-frontend"
          BACKEND_IMAGE="${{ env.DOCKER_REGISTRY }}/${REPO_LOWER}/ai-firefighter-backend"

          echo "frontend-base=${FRONTEND_IMAGE}" >> $GITHUB_OUTPUT
          echo "backend-base=${BACKEND_IMAGE}" >> $GITHUB_OUTPUT
          echo "build-tag=${BUILD_TAG}" >> $GITHUB_OUTPUT

      - name: Build and push Frontend
        uses: docker/build-push-action@v5
        with:
          context: ./FO
          file: ./FO/Dockerfile
          push: true
          tags: |
            ${{ steps.meta.outputs.frontend-base }}:${{ steps.meta.outputs.build-tag }}
            ${{ steps.meta.outputs.frontend-base }}:latest
          cache-from: type=gha,scope=frontend
          cache-to: type=gha,mode=max,scope=frontend
          platforms: linux/amd64

      - name: Build and push Backend
        uses: docker/build-push-action@v5
        with:
          context: ./API
          file: ./API/Dockerfile
          push: true
          tags: |
            ${{ steps.meta.outputs.backend-base }}:${{ steps.meta.outputs.build-tag }}
            ${{ steps.meta.outputs.backend-base }}:latest
          cache-from: type=gha,scope=backend
          cache-to: type=gha,mode=max,scope=backend
          platforms: linux/amd64

      - name: Set output images
        id: images
        run: |
          echo "frontend=${{ steps.meta.outputs.frontend-base }}:${{ steps.meta.outputs.build-tag }}" >> $GITHUB_OUTPUT
          echo "backend=${{ steps.meta.outputs.backend-base }}:${{ steps.meta.outputs.build-tag }}" >> $GITHUB_OUTPUT

      - name: Mark build success
        id: build_result
        run: echo "success=true" >> $GITHUB_OUTPUT

  backup_current:
    name: Backup Current State
    runs-on: ubuntu-latest
    needs: [build_images]
    outputs:
      backup_available: ${{ steps.backup.outputs.available }}
      backup_timestamp: ${{ steps.backup.outputs.timestamp }}

    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      - name: Create comprehensive backup
        id: backup
        run: |
          BACKUP_TIME=$(date +%Y%m%d-%H%M%S)

          backup_result=$(ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
            sudo mkdir -p /opt/firefighter-backups
            sudo chown -R ${{ secrets.PRODUCTION_USER }}:${{ secrets.PRODUCTION_USER }} /opt/firefighter-backups

            cd /opt/firefighter-app 2>/dev/null || { echo 'NO_APP_DIR'; exit 0; }

            mkdir -p /opt/firefighter-backups/$BACKUP_TIME

            if [ -f docker-compose.yml ]; then
              cp docker-compose.yml /opt/firefighter-backups/$BACKUP_TIME/
              echo 'COMPOSE_BACKED_UP'
            fi

            if [ -f .env ]; then
              cp .env /opt/firefighter-backups/$BACKUP_TIME/
              echo 'ENV_BACKED_UP'
            fi

            if command -v docker >/dev/null 2>&1; then
              docker ps --format 'table {{.Image}}\t{{.Names}}\t{{.Ports}}\t{{.Status}}' > /opt/firefighter-backups/$BACKUP_TIME/current-containers.txt 2>/dev/null || echo 'No containers running' > /opt/firefighter-backups/$BACKUP_TIME/current-containers.txt
              docker-compose ps --format json > /opt/firefighter-backups/$BACKUP_TIME/container-status.json 2>/dev/null || echo '[]' > /opt/firefighter-backups/$BACKUP_TIME/container-status.json
              echo 'DOCKER_STATE_BACKED_UP'
            fi

            echo 'BACKUP_CREATED'
          " 2>&1) || echo "BACKUP_FAILED"

          if echo "$backup_result" | grep -q "BACKUP_CREATED"; then
            echo "available=true" >> $GITHUB_OUTPUT
            echo "timestamp=$BACKUP_TIME" >> $GITHUB_OUTPUT
            echo "Backup created successfully at $BACKUP_TIME"
          else
            echo "available=false" >> $GITHUB_OUTPUT
            echo "timestamp=" >> $GITHUB_OUTPUT
            echo "Backup failed or not needed: $backup_result"
          fi

          rm -f ~/.ssh/id_rsa

  prepare_deployment_files:
    name: Prepare Deployment Files
    runs-on: ubuntu-latest
    needs: [build_images]

    steps:
      - name: Create deployment files locally
        run: |
          mkdir -p deployment_files

          # Create docker-compose file
          cat > deployment_files/docker-compose.yml << 'EOF'
          version: '3.8'
          services:
            backend:
              image: ${{ needs.build_images.outputs.backend_image }}
              ports:
                - '5000:5000'
              environment:
                - DB_USERNAME=${{ secrets.DB_USERNAME }}
                - DB_PASSWORD=${{ secrets.DB_PASSWORD }}
                - DB_CLUSTER=${{ secrets.DB_CLUSTER }}
                - FLASK_ENV=production
              restart: unless-stopped
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:5000/"]
                interval: 30s
                timeout: 10s
                retries: 3

            frontend:
              image: ${{ needs.build_images.outputs.frontend_image }}
              ports:
                - '8000:8000'
              environment:
                - DB_USERNAME=${{ secrets.DB_USERNAME }}
                - DB_PASSWORD=${{ secrets.DB_PASSWORD }}
                - DB_CLUSTER=${{ secrets.DB_CLUSTER }}
                - FLASK_ENV=production
                - API_BASE_URL=http://backend:5000/api
              restart: unless-stopped
              depends_on:
                - backend
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:8000/"]
                interval: 30s
                timeout: 10s
                retries: 3
          EOF

      - name: Upload deployment files
        uses: actions/upload-artifact@v4
        with:
          name: deployment-files
          path: deployment_files/
          retention-days: 1

  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build_images, backup_current, prepare_deployment_files, validate_environment]
    outputs:
      deployment_status: ${{ steps.deploy.outputs.status }}
      frontend_working: ${{ steps.deploy.outputs.frontend_ok }}
      backend_working: ${{ steps.deploy.outputs.backend_ok }}

    steps:
      - name: Download deployment files
        uses: actions/download-artifact@v4
        with:
          name: deployment-files
          path: deployment_files

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      - name: Prepare server environment
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
            if ! command -v docker >/dev/null 2>&1; then
              curl -fsSL https://get.docker.com | sh
              usermod -aG docker ${{ secrets.PRODUCTION_USER }}
            fi

            if ! command -v docker-compose >/dev/null 2>&1; then
              curl -L \"https://github.com/docker/compose/releases/latest/download/docker-compose-\$(uname -s)-\$(uname -m)\" -o /usr/local/bin/docker-compose
              chmod +x /usr/local/bin/docker-compose
            fi

            mkdir -p /opt/firefighter-app
            chown -R ${{ secrets.PRODUCTION_USER }}:${{ secrets.PRODUCTION_USER }} /opt/firefighter-app
          "

      - name: Upload deployment files to server
        run: |
          scp -o StrictHostKeyChecking=no deployment_files/docker-compose.yml ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }}:/opt/firefighter-app/

      - name: Attempt normal deployment
        id: deploy
        run: |
          deployment_success="false"
          frontend_ok="false"
          backend_ok="false"

          for attempt in 1 2; do
            echo "Deployment attempt $attempt/2..."

            deployment_result=$(ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
              cd /opt/firefighter-app

              # Login to registry
              echo '${{ secrets.GITHUB_TOKEN }}' | docker login ${{ env.DOCKER_REGISTRY }} -u ${{ github.actor }} --password-stdin

              # Pull images
              docker pull ${{ needs.build_images.outputs.frontend_image }}
              docker pull ${{ needs.build_images.outputs.backend_image }}

              # Deploy
              docker-compose down --timeout 30 || true
              docker-compose up -d

              # Wait and test
              sleep 60

              # Test services
              frontend_status='FAIL'
              backend_status='FAIL'

              if curl -s --max-time 10 http://localhost:8000/ >/dev/null 2>&1; then
                frontend_status='OK'
              fi

              if curl -s --max-time 10 http://localhost:5000/ >/dev/null 2>&1; then
                backend_status='OK'
              fi

              echo \"FRONTEND_STATUS=\$frontend_status\"
              echo \"BACKEND_STATUS=\$backend_status\"

              if [ \"\$frontend_status\" = 'OK' ] && [ \"\$backend_status\" = 'OK' ]; then
                echo 'DEPLOYMENT_SUCCESS'
              else
                echo 'DEPLOYMENT_FAILED'
                docker-compose logs --tail=20
              fi
            " 2>&1)

            echo "$deployment_result"

            if echo "$deployment_result" | grep -q "FRONTEND_STATUS=OK"; then
              frontend_ok="true"
            fi

            if echo "$deployment_result" | grep -q "BACKEND_STATUS=OK"; then
              backend_ok="true"
            fi

            if echo "$deployment_result" | grep -q "DEPLOYMENT_SUCCESS"; then
              deployment_success="true"
              break
            fi

            echo "Attempt $attempt failed, will retry..."
            sleep 30
          done

          echo "status=$deployment_success" >> $GITHUB_OUTPUT
          echo "frontend_ok=$frontend_ok" >> $GITHUB_OUTPUT
          echo "backend_ok=$backend_ok" >> $GITHUB_OUTPUT

          rm -f ~/.ssh/id_rsa

  emergency_fallback:
    name: Emergency Fallback (All Services)
    runs-on: ubuntu-latest
    needs: [deploy, validate_environment]
    if: always() && (needs.deploy.outputs.deployment_status != 'true' || needs.deploy.outputs.frontend_working != 'true' || needs.deploy.outputs.backend_working != 'true')
    outputs:
      emergency_status: ${{ steps.emergency.outputs.status }}

    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      - name: Execute emergency deployment for all services (no artifact)
        id: emergency
        run: |
          echo "🚨 EXECUTING EMERGENCY FALLBACK - ALL SERVICES 🚨"

          # Crear script local temporal
          cat > emergency-deploy.sh << 'EOF'
          #!/bin/bash
          echo '🚨 EMERGENCY DEPLOYMENT - ALL SERVICES 🚨'

          # Quitar CRLF por si el archivo viene de Windows
          sed -i 's/\r$//' "$0" 2>/dev/null || true

          # Parar todo
          docker-compose down --timeout 30 2>/dev/null || true
          docker stop $(docker ps -aq) 2>/dev/null || true
          docker rm $(docker ps -aq) 2>/dev/null || true

          # Login al registry (best effort)
          if command -v docker >/dev/null 2>&1; then
            echo "${GITHUB_TOKEN}" | docker login ghcr.io -u ${GITHUB_ACTOR} --password-stdin 2>/dev/null || true
          fi

          # Backend estable
          echo 'Starting emergency backend...'
          docker run -d --name emergency-backend -p 5000:5000 \
            -e DB_USERNAME="$1" \
            -e DB_PASSWORD="$2" \
            -e DB_CLUSTER="$3" \
            -e FLASK_ENV=production \
            --restart unless-stopped \
            ghcr.io/josojmf/ai-firefighter-backend:stable || true

          # Frontend estable
          echo 'Starting emergency frontend...'
          docker run -d --name emergency-frontend -p 8000:8000 \
            -e FLASK_ENV=production \
            -e API_BASE_URL=http://localhost:5000/api \
            --restart unless-stopped \
            ghcr.io/josojmf/ai-firefighter-frontend:stable || true

          # Esperar y comprobar
          sleep 30

          FRONTEND_OK=false
          BACKEND_OK=false

          if curl -s --max-time 10 http://localhost:8000/ >/dev/null; then
            echo '✅ Frontend is running'
            FRONTEND_OK=true
          else
            echo '❌ Frontend failed'
          fi

          if curl -s --max-time 10 http://localhost:5000/ >/dev/null; then
            echo '✅ Backend is running'
            BACKEND_OK=true
          else
            echo '❌ Backend failed'
          fi

          if [ "$FRONTEND_OK" = true ] && [ "$BACKEND_OK" = true ]; then
            echo '✅ EMERGENCY SUCCESS - All services running'
            exit 0
          elif [ "$FRONTEND_OK" = true ]; then
            echo '⚠️ EMERGENCY PARTIAL SUCCESS - Frontend running'
            exit 0
          else
            echo '❌ EMERGENCY FAILED'
            exit 1
          fi
          EOF

          # Subir y ejecutar en servidor
          scp -o StrictHostKeyChecking=no emergency-deploy.sh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }}:/opt/firefighter-app/
          ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
            chmod +x /opt/firefighter-app/emergency-deploy.sh
            sed -i 's/\r$//' /opt/firefighter-app/emergency-deploy.sh || true
            /opt/firefighter-app/emergency-deploy.sh '${{ secrets.DB_USERNAME }}' '${{ secrets.DB_PASSWORD }}' '${{ secrets.DB_CLUSTER }}'
          " 2>&1 | tee emergency.log

          if grep -q "EMERGENCY SUCCESS" emergency.log; then
            echo "status=success" >> $GITHUB_OUTPUT
          elif grep -q "PARTIAL SUCCESS" emergency.log; then
            echo "status=partial" >> $GITHUB_OUTPUT
          else
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

          rm -f ~/.ssh/id_rsa emergency-deploy.sh emergency.log

  rollback:
    name: Rollback to Previous Version
    runs-on: ubuntu-latest
    needs: [deploy, backup_current, emergency_fallback]
    if: always() && needs.deploy.outputs.deployment_status != 'true' && needs.emergency_fallback.outputs.emergency_status != 'success' && needs.backup_current.outputs.backup_available == 'true'

    steps:
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      - name: Perform rollback
        run: |
          echo "🔄 PERFORMING ROLLBACK TO PREVIOUS VERSION"

          rollback_result=$(ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
            cd /opt/firefighter-app

            # Find most recent backup
            LATEST_BACKUP=\$(ls -t /opt/firefighter-backups/ 2>/dev/null | head -1)

            if [ -n \"\$LATEST_BACKUP\" ] && [ -d \"/opt/firefighter-backups/\$LATEST_BACKUP\" ]; then
              echo \"Rolling back to backup: \$LATEST_BACKUP\"

              # Stop current deployment
              docker-compose down --timeout 30 || docker stop \$(docker ps -aq) || true

              # Restore backup files
              [ -f \"/opt/firefighter-backups/\$LATEST_BACKUP/docker-compose.yml\" ] && \
                cp \"/opt/firefighter-backups/\$LATEST_BACKUP/docker-compose.yml\" ./
              [ -f \"/opt/firefighter-backups/\$LATEST_BACKUP/.env\" ] && \
                cp \"/opt/firefighter-backups/\$LATEST_BACKUP/.env\" ./

              # Start previous version
              docker-compose up -d

              sleep 30

              # Test rollback
              if curl -s --max-time 10 http://localhost:8000/ >/dev/null; then
                echo 'ROLLBACK_SUCCESS'
              else
                echo 'ROLLBACK_FAILED'
              fi
            else
              echo 'NO_BACKUP_AVAILABLE'
            fi
          " 2>&1)

          echo "$rollback_result"

          rm -f ~/.ssh/id_rsa

  health_check:
    name: Final Health Check
    runs-on: ubuntu-latest
    needs: [deploy, emergency_fallback, rollback]
    if: always()
    outputs:
      final_status: ${{ steps.health.outputs.status }}
      services_healthy: ${{ steps.health.outputs.services }}

    steps:
      - name: Comprehensive health check
        id: health
        run: |
          echo "🏥 FINAL HEALTH CHECK - ALL SERVICES"

          sleep 30

          # Test both services
          frontend_status="DOWN"
          backend_status="DOWN"

          for i in {1..5}; do
            if curl -s --max-time 10 "http://${{ secrets.PRODUCTION_HOST }}:8000/" >/dev/null 2>&1; then
              frontend_status="UP"
            fi

            if curl -s --max-time 10 "http://${{ secrets.PRODUCTION_HOST }}:5000/" >/dev/null 2>&1; then
              backend_status="UP"
            fi

            if [ "$frontend_status" = "UP" ] && [ "$backend_status" = "UP" ]; then
              break
            fi
            sleep 10
          done

          echo "Frontend: $frontend_status"
          echo "Backend: $backend_status"

          if [ "$frontend_status" = "UP" ] && [ "$backend_status" = "UP" ]; then
            echo "status=healthy" >> $GITHUB_OUTPUT
            echo "services=all" >> $GITHUB_OUTPUT
            echo "✅ SYSTEM IS HEALTHY - All services responding"
          elif [ "$frontend_status" = "UP" ]; then
            echo "status=degraded" >> $GITHUB_OUTPUT
            echo "services=frontend_only" >> $GITHUB_OUTPUT
            echo "⚠️ SYSTEM DEGRADED - Frontend responding, Backend down"
          else
            echo "status=critical" >> $GITHUB_OUTPUT
            echo "services=none" >> $GITHUB_OUTPUT
            echo "❌ CRITICAL - No services responding"
            exit 1
          fi

  tag_stable:
    name: Tag Stable Version
    runs-on: ubuntu-latest
    needs: [build_images, health_check]
    if: always() && needs.health_check.outputs.final_status == 'healthy' && needs.build_images.result == 'success'
    permissions:
      contents: read
      packages: write

    steps:
      - name: Login to registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Tag as stable
        run: |
          # Tag frontend as stable
          docker pull ${{ needs.build_images.outputs.frontend_image }}
          FRONTEND_BASE=$(echo "${{ needs.build_images.outputs.frontend_image }}" | cut -d':' -f1)
          docker tag ${{ needs.build_images.outputs.frontend_image }} ${FRONTEND_BASE}:stable
          docker push ${FRONTEND_BASE}:stable

          # Tag backend as stable
          docker pull ${{ needs.build_images.outputs.backend_image }}
          BACKEND_BASE=$(echo "${{ needs.build_images.outputs.backend_image }}" | cut -d':' -f1)
          docker tag ${{ needs.build_images.outputs.backend_image }} ${BACKEND_BASE}:stable
          docker push ${BACKEND_BASE}:stable

          echo "Stable versions tagged successfully for both services"

  notify:
    name: Deployment Report
    runs-on: ubuntu-latest
    needs: [pre_deployment, validate_environment, build_images, deploy, emergency_fallback, rollback, health_check, tag_stable]
    if: always()

    steps:
      - name: Generate comprehensive report
        run: |
          echo "🚒 AI FIREFIGHTER DEPLOYMENT REPORT 🚒" | tee report.md
          echo "==========================================" | tee -a report.md
          echo "Timestamp: $(date -u)" | tee -a report.md
          echo "Commit: ${{ github.sha }}" | tee -a report.md
          echo "" | tee -a report.md

          # Job Results
          echo "## Job Results:" | tee -a report.md
          echo "- Pre-deployment: ${{ needs.pre_deployment.result }}" | tee -a report.md
          echo "- Environment Validation: ${{ needs.validate_environment.result }}" | tee -a report.md
          echo "- Build Images: ${{ needs.build_images.result }}" | tee -a report.md
          echo "- Deploy: ${{ needs.deploy.result }}" | tee -a report.md
          echo "- Emergency Fallback: ${{ needs.emergency_fallback.result }}" | tee -a report.md
          echo "- Rollback: ${{ needs.rollback.result }}" | tee -a report.md
          echo "- Health Check: ${{ needs.health_check.result }}" | tee -a report.md
          echo "- Tag Stable: ${{ needs.tag_stable.result }}" | tee -a report.md
          echo "" | tee -a report.md

          # Final Status
          if [ "${{ needs.health_check.outputs.final_status }}" = "healthy" ]; then
            echo "## ✅ DEPLOYMENT SUCCESSFUL - ALL SERVICES" | tee -a report.md
            echo "Frontend: http://167.71.42.17:8000" | tee -a report.md
            echo "Backend: http://167.71.42.17:5000" | tee -a report.md
          elif [ "${{ needs.health_check.outputs.final_status }}" = "degraded" ]; then
            echo "## ⚠️ DEPLOYMENT PARTIAL SUCCESS" | tee -a report.md
            echo "Frontend: http://167.71.42.17:8000 ✅" | tee -a report.md
            echo "Backend: http://167.71.42.17:5000 ❌" | tee -a report.md
          else
            echo "## ❌ DEPLOYMENT FAILED" | tee -a report.md
            echo "All deployment strategies failed" | tee -a report.md
          fi

          echo "" | tee -a report.md
          echo "## Deployment Strategy Used:" | tee -a report.md
          if [ "${{ needs.deploy.result }}" = "success" ]; then
            echo "- ✅ Normal deployment" | tee -a report.md
          elif [ "${{ needs.emergency_fallback.result }}" = "success" ]; then
            echo "- 🚨 Emergency deployment" | tee -a report.md
          elif [ "${{ needs.rollback.result }}" = "success" ]; then
            echo "- 🔄 Rollback deployment" | tee -a report.md
          fi

      - name: Upload report
        uses: actions/upload-artifact@v4
        with:
          name: deployment-report-${{ github.run_id }}
          path: report.md
          retention-days: 30
