name: CD Pipeline - Ultra Robust with Emergency Fallback

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment'
        required: false
        default: false
        type: boolean
      emergency_mode:
        description: 'Deploy in emergency mode (frontend only)'
        required: false
        default: false
        type: boolean

env:
  DOCKER_REGISTRY: ghcr.io
  DEPLOYMENT_TIMEOUT: 180 # 3 minutes max per attempt
  MAX_DEPLOYMENT_ATTEMPTS: 2

jobs:
  pre-deployment:
    name: Pre-deployment Safety Check
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      deploy_mode: ${{ steps.check.outputs.deploy_mode }}
    
    steps:
    - name: Determine deployment strategy
      id: check
      run: |
        should_deploy="true"
        deploy_mode="normal"
        
        if [ "${{ github.event.inputs.emergency_mode }}" = "true" ]; then
          echo "Emergency deployment mode requested"
          deploy_mode="emergency"
        elif [ "${{ github.event.inputs.force_deploy }}" = "true" ]; then
          echo "Force deployment requested"
          deploy_mode="force"
        else
          echo "Normal deployment mode"
          deploy_mode="normal"
        fi
        
        echo "should_deploy=$should_deploy" >> $GITHUB_OUTPUT
        echo "deploy_mode=$deploy_mode" >> $GITHUB_OUTPUT

  validate-environment:
    name: Validate Production Environment
    runs-on: ubuntu-latest
    needs: pre-deployment
    outputs:
      environment-ready: ${{ steps.validate.outputs.ready }}
      current-status: ${{ steps.validate.outputs.status }}
    
    steps:
    - name: Check required secrets
      run: |
        missing=()
        
        [ -z "${{ secrets.PRODUCTION_SSH_KEY }}" ] && missing+=("PRODUCTION_SSH_KEY")
        [ -z "${{ secrets.PRODUCTION_HOST }}" ] && missing+=("PRODUCTION_HOST")
        [ -z "${{ secrets.PRODUCTION_USER }}" ] && missing+=("PRODUCTION_USER")
        [ -z "${{ secrets.DB_USERNAME }}" ] && missing+=("DB_USERNAME")
        [ -z "${{ secrets.DB_PASSWORD }}" ] && missing+=("DB_PASSWORD")
        [ -z "${{ secrets.DB_CLUSTER }}" ] && missing+=("DB_CLUSTER")
        
        if [ ${#missing[@]} -ne 0 ]; then
          echo "Missing secrets: ${missing[*]}"
          exit 1
        fi
        
        echo "All secrets configured"

    - name: Validate production server
      id: validate
      run: |
        # SSH key setup
        mkdir -p ~/.ssh
        echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts
        
        # Check server accessibility and current status
        current_status=$(ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 \
          ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
          echo 'Server accessible'
          
          # Check if there's something currently running
          if curl -s --max-time 5 http://localhost:8000/ >/dev/null 2>&1; then
            echo 'CURRENT_SERVICE_RUNNING=true'
          else
            echo 'CURRENT_SERVICE_RUNNING=false'
          fi
          
          # Check Docker status
          if command -v docker >/dev/null 2>&1; then
            echo 'DOCKER_AVAILABLE=true'
          else
            echo 'DOCKER_AVAILABLE=false'
          fi
          
          # Check deployment directory
          if [ -d /opt/firefighter-app ]; then
            echo 'DEPLOY_DIR_EXISTS=true'
          else
            echo 'DEPLOY_DIR_EXISTS=false'
          fi
        " 2>&1) || echo "SSH_FAILED=true"
        
        echo "$current_status"
        
        if echo "$current_status" | grep -q "SSH_FAILED=true"; then
          echo "ready=false" >> $GITHUB_OUTPUT
          echo "status=ssh_failed" >> $GITHUB_OUTPUT
          exit 1
        elif echo "$current_status" | grep -q "CURRENT_SERVICE_RUNNING=true"; then
          echo "ready=true" >> $GITHUB_OUTPUT
          echo "status=service_running" >> $GITHUB_OUTPUT
        else
          echo "ready=true" >> $GITHUB_OUTPUT  
          echo "status=no_service" >> $GITHUB_OUTPUT
        fi
        
        rm -f ~/.ssh/id_rsa

  build-images:
    name: Build and Push Images
    runs-on: ubuntu-latest
    needs: [pre-deployment, validate-environment]
    if: needs.validate-environment.outputs.environment-ready == 'true'
    permissions:
      contents: read
      packages: write
    outputs:
      frontend-image: ${{ steps.images.outputs.frontend }}
      backend-image: ${{ steps.images.outputs.backend }}
      build-success: ${{ steps.build-result.outputs.success }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Login to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.DOCKER_REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Generate image names and tags
      id: meta
      run: |
        REPO_LOWER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
        TIMESTAMP=$(date +%Y%m%d-%H%M%S)
        SHORT_SHA=${GITHUB_SHA:0:7}
        BUILD_TAG="${TIMESTAMP}-${SHORT_SHA}"
        
        FRONTEND_IMAGE="${{ env.DOCKER_REGISTRY }}/${REPO_LOWER}/ai-firefighter-frontend"
        BACKEND_IMAGE="${{ env.DOCKER_REGISTRY }}/${REPO_LOWER}/ai-firefighter-backend"
        
        echo "frontend-base=${FRONTEND_IMAGE}" >> $GITHUB_OUTPUT
        echo "backend-base=${BACKEND_IMAGE}" >> $GITHUB_OUTPUT
        echo "build-tag=${BUILD_TAG}" >> $GITHUB_OUTPUT

    - name: Build and push Frontend
      uses: docker/build-push-action@v5
      with:
        context: ./FO
        file: ./FO/Dockerfile
        push: true
        tags: |
          ${{ steps.meta.outputs.frontend-base }}:${{ steps.meta.outputs.build-tag }}
          ${{ steps.meta.outputs.frontend-base }}:latest
        cache-from: type=gha,scope=frontend
        cache-to: type=gha,mode=max,scope=frontend
        platforms: linux/amd64

    - name: Build and push Backend
      uses: docker/build-push-action@v5
      with:
        context: ./API
        file: ./API/Dockerfile
        push: true
        tags: |
          ${{ steps.meta.outputs.backend-base }}:${{ steps.meta.outputs.build-tag }}
          ${{ steps.meta.outputs.backend-base }}:latest
        cache-from: type=gha,scope=backend
        cache-to: type=gha,mode=max,scope=backend
        platforms: linux/amd64

    - name: Set output images
      id: images
      run: |
        echo "frontend=${{ steps.meta.outputs.frontend-base }}:${{ steps.meta.outputs.build-tag }}" >> $GITHUB_OUTPUT
        echo "backend=${{ steps.meta.outputs.backend-base }}:${{ steps.meta.outputs.build-tag }}" >> $GITHUB_OUTPUT

    - name: Mark build success
      id: build-result
      run: echo "success=true" >> $GITHUB_OUTPUT

  backup-current:
    name: Backup Current State
    runs-on: ubuntu-latest
    needs: [build-images]
    outputs:
      backup-available: ${{ steps.backup.outputs.available }}
    
    steps:
    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

    - name: Create backup
      id: backup
      run: |
        BACKUP_TIME=$(date +%Y%m%d-%H%M%S)
        
        backup_result=$(ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
          # Ensure backup directory exists
          sudo mkdir -p /opt/firefighter-backups
          sudo chown -R ${{ secrets.PRODUCTION_USER }}:${{ secrets.PRODUCTION_USER }} /opt/firefighter-backups
          
          cd /opt/firefighter-app 2>/dev/null || { echo 'NO_APP_DIR'; exit 0; }
          
          if [ -f docker-compose.yml ] && [ -f .env ]; then
            mkdir -p /opt/firefighter-backups/$BACKUP_TIME
            cp docker-compose.yml .env /opt/firefighter-backups/$BACKUP_TIME/
            docker-compose ps --format json > /opt/firefighter-backups/$BACKUP_TIME/container-status.json 2>/dev/null || echo '[]' > /opt/firefighter-backups/$BACKUP_TIME/container-status.json
            echo 'BACKUP_CREATED'
          else
            echo 'NO_BACKUP_NEEDED'
          fi
        " 2>&1) || echo "BACKUP_FAILED"
        
        if echo "$backup_result" | grep -q "BACKUP_CREATED"; then
          echo "available=true" >> $GITHUB_OUTPUT
          echo "Backup created successfully"
        else
          echo "available=false" >> $GITHUB_OUTPUT
          echo "No backup needed or backup failed: $backup_result"
        fi
        
        rm -f ~/.ssh/id_rsa

  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-images, backup-current, validate-environment]
    outputs:
      deployment-status: ${{ steps.deploy.outputs.status }}
      frontend-working: ${{ steps.deploy.outputs.frontend_ok }}
      backend-working: ${{ steps.deploy.outputs.backend_ok }}
    
    steps:
    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

    - name: Prepare server environment
      run: |
        ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
          # Ensure Docker is installed
          if ! command -v docker >/dev/null 2>&1; then
            curl -fsSL https://get.docker.com | sh
            usermod -aG docker ${{ secrets.PRODUCTION_USER }}
          fi
          
          # Ensure Docker Compose is installed
          if ! command -v docker-compose >/dev/null 2>&1; then
            curl -L \"https://github.com/docker/compose/releases/latest/download/docker-compose-\$(uname -s)-\$(uname -m)\" -o /usr/local/bin/docker-compose
            chmod +x /usr/local/bin/docker-compose
          fi
          
          # Setup deployment directory
          mkdir -p /opt/firefighter-app
          chown -R ${{ secrets.PRODUCTION_USER }}:${{ secrets.PRODUCTION_USER }} /opt/firefighter-app
        "

    - name: Create emergency deployment script
      run: |
        ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
          cat > /opt/firefighter-app/emergency-deploy.sh << 'EMERGENCY_SCRIPT'
          #!/bin/bash
          echo '🚨 EMERGENCY DEPLOYMENT - FRONTEND ONLY 🚨'
          
          # Stop everything
          docker stop \$(docker ps -aq) 2>/dev/null || true
          docker rm \$(docker ps -aq) 2>/dev/null || true
          
          # Start only frontend with latest stable image
          echo 'Starting emergency frontend...'
          docker run -d --name emergency-frontend -p 8000:8000 \\
            -e FLASK_ENV=production \\
            -e API_BASE_URL=http://localhost:5000/api \\
            --restart unless-stopped \\
            ghcr.io/josojmf/ai-firefighter-frontend:latest || \\
          docker run -d --name emergency-frontend -p 8000:8000 \\
            -e FLASK_ENV=production \\
            --restart unless-stopped \\
            ghcr.io/josojmf/ai-firefighter-frontend:20250922-180353-8984cd5
          
          sleep 10
          
          if curl -s --max-time 10 http://localhost:8000/ >/dev/null; then
            echo 'SUCCESS: Emergency frontend is running'
            echo 'Available at: http://167.71.42.17:8000'
          else
            echo 'FAILED: Emergency deployment failed'
            exit 1
          fi
        EMERGENCY_SCRIPT
          
          chmod +x /opt/firefighter-app/emergency-deploy.sh
        "

    - name: Attempt normal deployment
      id: deploy
      run: |
        deployment_success="false"
        frontend_ok="false"
        backend_ok="false"
        
        for attempt in 1 2; do
          echo "Deployment attempt $attempt/2..."
          
          deployment_result=$(ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
            cd /opt/firefighter-app
            
            # Create docker-compose configuration
            cat > docker-compose.yml << 'COMPOSE_EOF'
            version: '3.8'
            services:
              frontend:
                image: ${{ needs.build-images.outputs.frontend-image }}
                ports:
                  - '8000:8000'
                environment:
                  - DB_USERNAME=${{ secrets.DB_USERNAME }}
                  - DB_PASSWORD=${{ secrets.DB_PASSWORD }}
                  - DB_CLUSTER=${{ secrets.DB_CLUSTER }}
                  - FLASK_ENV=production
                  - API_BASE_URL=http://localhost:5000/api
                restart: unless-stopped
                depends_on:
                  - backend

              backend:
                image: ${{ needs.build-images.outputs.backend-image }}
                ports:
                  - '5000:5000'
                environment:
                  - DB_USERNAME=${{ secrets.DB_USERNAME }}
                  - DB_PASSWORD=${{ secrets.DB_PASSWORD }}
                  - DB_CLUSTER=${{ secrets.DB_CLUSTER }}
                  - FLASK_ENV=production
                restart: unless-stopped
            COMPOSE_EOF
            
            # Login to registry
            echo '${{ secrets.GITHUB_TOKEN }}' | docker login ${{ env.DOCKER_REGISTRY }} -u ${{ github.actor }} --password-stdin
            
            # Pull images
            docker pull ${{ needs.build-images.outputs.frontend-image }}
            docker pull ${{ needs.build-images.outputs.backend-image }}
            
            # Deploy
            docker-compose down --timeout 30 || true
            docker-compose up -d
            
            # Wait and test
            sleep 60
            
            # Test services
            frontend_status='FAIL'
            backend_status='FAIL'
            
            if curl -s --max-time 10 http://localhost:8000/ >/dev/null 2>&1; then
              frontend_status='OK'
            fi
            
            if curl -s --max-time 10 http://localhost:5000/ >/dev/null 2>&1; then
              backend_status='OK'
            fi
            
            echo \"FRONTEND_STATUS=\$frontend_status\"
            echo \"BACKEND_STATUS=\$backend_status\"
            
            if [ \"\$frontend_status\" = 'OK' ]; then
              echo 'DEPLOYMENT_SUCCESS'
            else
              echo 'DEPLOYMENT_FAILED'
              docker-compose logs --tail=20
            fi
          " 2>&1) || echo "DEPLOYMENT_ATTEMPT_FAILED"
          
          echo "$deployment_result"
          
          # Check results
          if echo "$deployment_result" | grep -q "FRONTEND_STATUS=OK"; then
            frontend_ok="true"
          fi
          
          if echo "$deployment_result" | grep -q "BACKEND_STATUS=OK"; then
            backend_ok="true"
          fi
          
          if echo "$deployment_result" | grep -q "DEPLOYMENT_SUCCESS"; then
            deployment_success="true"
            break
          fi
          
          echo "Attempt $attempt failed, will retry..." 
          sleep 30
        done
        
        echo "status=$deployment_success" >> $GITHUB_OUTPUT
        echo "frontend_ok=$frontend_ok" >> $GITHUB_OUTPUT
        echo "backend_ok=$backend_ok" >> $GITHUB_OUTPUT
        
        rm -f ~/.ssh/id_rsa

  emergency-fallback:
    name: Emergency Fallback
    runs-on: ubuntu-latest
    needs: [deploy, validate-environment]
    if: always() && (needs.deploy.outputs.deployment-status != 'true' || needs.deploy.outputs.frontend-working != 'true')
    
    steps:
    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

    - name: Execute emergency deployment
      run: |
        echo "🚨 EXECUTING EMERGENCY FALLBACK 🚨"
        
        emergency_result=$(ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
          cd /opt/firefighter-app
          
          # Execute emergency script
          if [ -f emergency-deploy.sh ]; then
            ./emergency-deploy.sh
          else
            echo 'Emergency script not found, executing inline emergency deployment'
            
            # Stop everything
            docker stop \$(docker ps -aq) 2>/dev/null || true
            docker rm \$(docker ps -aq) 2>/dev/null || true
            
            # Try latest first, then fallback to known working image
            docker run -d --name emergency-frontend -p 8000:8000 \\
              -e FLASK_ENV=production \\
              --restart unless-stopped \\
              ghcr.io/josojmf/ai-firefighter-frontend:latest || \\
            docker run -d --name emergency-frontend -p 8000:8000 \\
              -e FLASK_ENV=production \\
              --restart unless-stopped \\
              ghcr.io/josojmf/ai-firefighter-frontend:20250922-180353-8984cd5
            
            sleep 15
            
            if curl -s --max-time 10 http://localhost:8000/ >/dev/null; then
              echo 'EMERGENCY_SUCCESS'
            else
              echo 'EMERGENCY_FAILED'
              exit 1
            fi
          fi
        " 2>&1)
        
        echo "$emergency_result"
        
        if echo "$emergency_result" | grep -q "EMERGENCY_SUCCESS\|SUCCESS.*frontend"; then
          echo "✅ Emergency deployment successful - Frontend is running"
        else
          echo "❌ Emergency deployment failed"
          exit 1
        fi
        
        rm -f ~/.ssh/id_rsa

  rollback:
    name: Rollback to Previous Version  
    runs-on: ubuntu-latest
    needs: [deploy, backup-current, emergency-fallback]
    if: always() && needs.deploy.outputs.deployment-status != 'true' && needs.emergency-fallback.result != 'success' && needs.backup-current.outputs.backup-available == 'true'
    
    steps:
    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

    - name: Perform rollback
      run: |
        echo "🔄 PERFORMING ROLLBACK TO PREVIOUS VERSION"
        
        rollback_result=$(ssh -o StrictHostKeyChecking=no ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "
          cd /opt/firefighter-app
          
          # Find most recent backup
          LATEST_BACKUP=\$(ls -t /opt/firefighter-backups/ 2>/dev/null | head -1)
          
          if [ -n \"\$LATEST_BACKUP\" ] && [ -d \"/opt/firefighter-backups/\$LATEST_BACKUP\" ]; then
            echo \"Rolling back to: \$LATEST_BACKUP\"
            
            # Stop current deployment
            docker-compose down --timeout 30 || docker stop \$(docker ps -aq) || true
            
            # Restore backup files
            cp /opt/firefighter-backups/\$LATEST_BACKUP/docker-compose.yml ./
            cp /opt/firefighter-backups/\$LATEST_BACKUP/.env ./
            
            # Start previous version
            docker-compose up -d
            
            sleep 30
            
            # Test rollback
            if curl -s --max-time 10 http://localhost:8000/ >/dev/null; then
              echo 'ROLLBACK_SUCCESS'
            else
              echo 'ROLLBACK_FAILED'
              # Last resort - emergency deployment
              /opt/firefighter-app/emergency-deploy.sh
            fi
          else
            echo 'NO_BACKUP_AVAILABLE - executing emergency deployment'
            /opt/firefighter-app/emergency-deploy.sh
          fi
        " 2>&1)
        
        echo "$rollback_result"
        
        rm -f ~/.ssh/id_rsa

  health-check:
    name: Final Health Check
    runs-on: ubuntu-latest
    needs: [deploy, emergency-fallback, rollback]
    if: always()
    outputs:
      final-status: ${{ steps.health.outputs.status }}
    
    steps:
    - name: Comprehensive health check
      id: health
      run: |
        echo "🏥 FINAL HEALTH CHECK"
        
        # Wait for services to stabilize
        sleep 30
        
        # Test frontend
        frontend_status="DOWN"
        for i in {1..5}; do
          if curl -s --max-time 10 "http://${{ secrets.PRODUCTION_HOST }}:8000/" >/dev/null 2>&1; then
            frontend_status="UP"
            break
          fi
          sleep 10
        done
        
        # Test backend  
        backend_status="DOWN"
        for i in {1..3}; do
          if curl -s --max-time 10 "http://${{ secrets.PRODUCTION_HOST }}:5000/" >/dev/null 2>&1; then
            backend_status="UP"
            break
          fi
          sleep 10
        done
        
        echo "Frontend: $frontend_status"
        echo "Backend: $backend_status"
        
        if [ "$frontend_status" = "UP" ]; then
          echo "status=healthy" >> $GITHUB_OUTPUT
          echo "✅ SYSTEM IS HEALTHY - Frontend responding"
        else
          echo "status=critical" >> $GITHUB_OUTPUT
          echo "❌ CRITICAL - No services responding"
          exit 1
        fi

  tag-stable:
    name: Tag Stable Version
    runs-on: ubuntu-latest
    needs: [build-images, health-check]
    if: always() && needs.health-check.outputs.final-status == 'healthy' && needs.build-images.result == 'success'
    permissions:
      contents: read
      packages: write
    
    steps:
    - name: Login to registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.DOCKER_REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Tag as stable
      run: |
        # Pull and tag frontend as stable
        docker pull ${{ needs.build-images.outputs.frontend-image }}
        FRONTEND_BASE=$(echo "${{ needs.build-images.outputs.frontend-image }}" | cut -d':' -f1)
        docker tag ${{ needs.build-images.outputs.frontend-image }} ${FRONTEND_BASE}:stable
        docker push ${FRONTEND_BASE}:stable
        
        # Try to tag backend as stable if available
        if docker pull ${{ needs.build-images.outputs.backend-image }} 2>/dev/null; then
          BACKEND_BASE=$(echo "${{ needs.build-images.outputs.backend-image }}" | cut -d':' -f1)
          docker tag ${{ needs.build-images.outputs.backend-image }} ${BACKEND_BASE}:stable
          docker push ${BACKEND_BASE}:stable
        fi
        
        echo "Stable versions tagged successfully"

  notify:
    name: Deployment Report
    runs-on: ubuntu-latest
    needs: [pre-deployment, validate-environment, build-images, deploy, emergency-fallback, rollback, health-check, tag-stable]
    if: always()
    
    steps:
    - name: Generate comprehensive report
      run: |
        echo "🚒 AI FIREFIGHTER DEPLOYMENT REPORT 🚒" | tee report.md
        echo "==========================================" | tee -a report.md
        echo "Timestamp: $(date -u)" | tee -a report.md
        echo "Commit: ${{ github.sha }}" | tee -a report.md
        echo "" | tee -a report.md
        
        # Job Results
        echo "## Job Results:" | tee -a report.md
        echo "- Pre-deployment: ${{ needs.pre-deployment.result }}" | tee -a report.md
        echo "- Environment Validation: ${{ needs.validate-environment.result }}" | tee -a report.md
        echo "- Build Images: ${{ needs.build-images.result }}" | tee -a report.md
        echo "- Deploy: ${{ needs.deploy.result }}" | tee -a report.md
        echo "- Emergency Fallback: ${{ needs.emergency-fallback.result }}" | tee -a report.md
        echo "- Rollback: ${{ needs.rollback.result }}" | tee -a report.md
        echo "- Health Check: ${{ needs.health-check.result }}" | tee -a report.md
        echo "- Tag Stable: ${{ needs.tag-stable.result }}" | tee -a report.md
        echo "" | tee -a report.md
        
        # Final Status
        if [ "${{ needs.health-check.outputs.final-status }}" = "healthy" ]; then
          echo "## ✅ DEPLOYMENT SUCCESSFUL" | tee -a report.md
          echo "Application is available at: http://167.71.42.17:8000" | tee -a report.md
          
          if [ "${{ needs.deploy.result }}" = "success" ]; then
            echo "✅ Normal deployment succeeded" | tee -a report.md
          elif [ "${{ needs.emergency-fallback.result }}" = "success" ]; then
            echo "⚠️ Emergency fallback deployment succeeded" | tee -a report.md
          elif [ "${{ needs.rollback.result }}" = "success" ]; then
            echo "🔄 Rollback deployment succeeded" | tee -a report.md
          fi
          
        else
          echo "## ❌ DEPLOYMENT FAILED" | tee -a report.md
          echo "All deployment strategies failed" | tee -a report.md
          echo "Manual intervention required" | tee -a report.md
        fi
        
        echo "" | tee -a report.md
        echo "## Service Status:" | tee -a report.md
        echo "- Frontend: ${{ needs.deploy.outputs.frontend-working == 'true' && '✅ Working' || '❌ Failed' }}" | tee -a report.md
        echo "- Backend: ${{ needs.deploy.outputs.backend-working == 'true' && '✅ Working' || '❌ Failed' }}" | tee -a report.md
        
        if [ "${{ needs.build-images.result }}" = "success" ]; then
          echo "" | tee -a report.md
          echo "## Images Built:" | tee -a report.md
          echo "- Frontend: ${{ needs.build-images.outputs.frontend-image }}" | tee -a report.md
          echo "- Backend: ${{ needs.build-images.outputs.backend-image }}" | tee -a report.md
        fi

    - name: Upload report
      uses: actions/upload-artifact@v4
      with:
        name: deployment-report-${{ github.run_id }}
        path: report.md
        retention-days: 30