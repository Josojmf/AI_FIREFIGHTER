name: ğŸš€ CD - Continuous Deployment

on:
  workflow_run:
    workflows: ["ğŸ”¬ CI - Continuous Integration"]
    types: [completed]
    branches: [main]

permissions:
  contents: read
  packages: read
  id-token: write

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: josojmf/ai-firefighter
  DEPLOYMENT_TIMEOUT: 600 # 10 minutes

jobs:
  # ============================================
  # JOB 1: Pre-deployment Validation
  # ============================================
  pre-deployment:
    name: ğŸ” Pre-deployment Validation
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    outputs:
      deployment_id: ${{ steps.generate-id.outputs.deployment_id }}
      current_version: ${{ steps.current-version.outputs.version }}
      image_tag: ${{ steps.image-tag.outputs.tag }}
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2 # âœ… Obtener los Ãºltimos 2 commits para acceder a HEAD~1

      - name: ğŸ†” Generate deployment ID
        id: generate-id
        run: |
          DEPLOYMENT_ID="deploy-$(date +%Y%m%d-%H%M%S)-${{ github.sha }}"
          echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "ğŸ†” Deployment ID: $DEPLOYMENT_ID"

      - name: ğŸ·ï¸ Generate image tag
        id: image-tag
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          IMAGE_TAG="main-${SHORT_SHA}"
          echo "tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "ğŸ·ï¸ Image tag: ${IMAGE_TAG}"

      - name: ğŸ” Validate required secrets
        run: |
          echo "ğŸ”’ Validating required secrets..."
          MISSING_SECRETS=()
          
          # Check each secret individually
          if [ -z "${{ secrets.PRODUCTION_SSH_KEY }}" ]; then
            MISSING_SECRETS+=("PRODUCTION_SSH_KEY")
          fi
          if [ -z "${{ secrets.PRODUCTION_HOST }}" ]; then
            MISSING_SECRETS+=("PRODUCTION_HOST")
          fi
          if [ -z "${{ secrets.MONGODB_URI }}" ]; then
            MISSING_SECRETS+=("MONGODB_URI")
          fi
          if [ -z "${{ secrets.JWT_SECRET }}" ]; then
            MISSING_SECRETS+=("JWT_SECRET")
          fi
          if [ -z "${{ secrets.SENDGRID_API_KEY }}" ]; then
            MISSING_SECRETS+=("SENDGRID_API_KEY")
          fi
          if [ -z "${{ secrets.ANTHROPIC_API_KEY }}" ]; then
            MISSING_SECRETS+=("ANTHROPIC_API_KEY")
          fi
          if [ -z "${{ secrets.ADMIN_PASSWORD }}" ]; then
            MISSING_SECRETS+=("ADMIN_PASSWORD")
          fi
          if [ -z "${{ secrets.SENDGRID_SENDER_EMAIL }}" ]; then
            MISSING_SECRETS+=("SENDGRID_SENDER_EMAIL")
          fi
          
          # Report results
          if [ ${#MISSING_SECRETS[@]} -ne 0 ]; then
            echo "âŒ Missing required secrets:"
            printf '%s\n' "${MISSING_SECRETS[@]}"
            exit 1
          fi
          
          echo "âœ… All required secrets are configured"

      - name: ğŸ³ Verify Docker images exist
        run: |
          echo "ğŸ” Verifying Docker images..."
          echo "â° Will wait up to 10 minutes for images to be available..."
          
          SERVICES="frontend backend backoffice"
          IMAGE_TAG="${{ steps.image-tag.outputs.tag }}"
          MAX_RETRIES=60
          RETRY_DELAY=10
          
          for service in $SERVICES; do
            IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-${service}:${IMAGE_TAG}"
            echo "Checking: $IMAGE"
            
            SUCCESS=false
            for attempt in $(seq 1 $MAX_RETRIES); do
              if docker manifest inspect $IMAGE > /dev/null 2>&1; then
                echo "âœ… Image exists: $service (attempt $attempt)"
                SUCCESS=true
                break
              fi
              
              if [ $attempt -eq 1 ]; then
                echo "â³ Image not ready yet, waiting for CI to finish building..."
              fi
              
              if [ $attempt -lt $MAX_RETRIES ]; then
                sleep $RETRY_DELAY
              fi
            done
            
            if [ "$SUCCESS" != "true" ]; then
              echo "âŒ Image not found after $MAX_RETRIES retries: $IMAGE"
              echo "Check if CI workflow completed successfully"
              exit 1
            fi
          done
          
          echo "âœ… All Docker images verified and ready"

      - name: ğŸ“‹ Get current production version
        id: current-version
        run: |
          # âœ… Manejar el caso cuando no hay commit previo (primer deploy)
          CURRENT_VERSION=$(git rev-parse HEAD~1 2>/dev/null || git rev-parse HEAD)
          echo "version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "ğŸ“Œ Current production version: $CURRENT_VERSION"

      - name: ğŸ“Š Create deployment record
        run: |
          echo "ğŸ“ Creating deployment record..."
          cat > deployment-info.json <<EOF
          {
            "deployment_id": "${{ steps.generate-id.outputs.deployment_id }}",
            "image_tag": "${{ steps.image-tag.outputs.tag }}",
            "commit_sha": "${{ github.sha }}",
            "previous_version": "${{ steps.current-version.outputs.version }}",
            "triggered_by": "${{ github.actor }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          }
          EOF
          cat deployment-info.json

  # ============================================
  # JOB 2: Backup Current Deployment
  # ============================================
  backup-deployment:
    name: ğŸ’¾ Backup Current Deployment
    runs-on: ubuntu-latest
    needs: [pre-deployment]
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      - name: ğŸ’¾ Backup current deployment
        run: |
          echo "ğŸ’¾ Backing up current deployment state..."
          ssh root@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
          # Create backup directory
          BACKUP_DIR="/root/backups/$(date +%Y%m%d-%H%M%S)"
          mkdir -p "$BACKUP_DIR"
          
          # Backup docker-compose files
          cp /root/docker-compose*.yml "$BACKUP_DIR/" 2>/dev/null || true
          
          # Backup environment files
          cp /root/.env* "$BACKUP_DIR/" 2>/dev/null || true
          
          # Export current running containers info
          docker ps --format "{{.Names}}: {{.Image}}" > "$BACKUP_DIR/running-containers.txt"
          
          # Save current service states
          docker service ls --format "{{.Name}}: {{.Replicas}}" > "$BACKUP_DIR/service-states.txt" 2>/dev/null || true
          
          # Keep only last 10 backups
          cd /root/backups
          ls -t | tail -n +11 | xargs -r rm -rf
          
          echo "âœ… Backup completed: $BACKUP_DIR"
          ENDSSH

      - name: ğŸ“Š Verify backup
        run: |
          ssh root@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
          LATEST_BACKUP=$(ls -t /root/backups | head -n 1)
          echo "ğŸ“ Latest backup: $LATEST_BACKUP"
          echo "ğŸ“‹ Backup contents:"
          ls -lah "/root/backups/$LATEST_BACKUP"
          ENDSSH

  # ============================================
  # JOB 3: Health Check Current Production
  # ============================================
  health-check-pre:
    name: ğŸ¥ Health Check (Pre-deployment)
    runs-on: ubuntu-latest
    needs: [pre-deployment]
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ¥ Check production health
        run: |
          echo "ğŸ¥ Checking current production health..."
          
          # Check frontend (usar / en vez de /health)
          FRONTEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.PRODUCTION_HOST }}:8000/ || echo "000")
          echo "Frontend health: $FRONTEND_STATUS"
          
          # Check API (usar /api/health en vez de /health)
          API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.PRODUCTION_HOST }}:5000/api/health || echo "000")
          echo "API health: $API_STATUS"
          
          # Check BackOffice
          BO_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.PRODUCTION_HOST }}:3001/health || echo "000")
          echo "BackOffice health: $BO_STATUS"
          
          # Create health report
          cat > health-report-pre.json <<EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "frontend": "$FRONTEND_STATUS",
            "api": "$API_STATUS",
            "backoffice": "$BO_STATUS"
          }
          EOF
          
          echo "ğŸ“Š Pre-deployment health check completed"

  # ============================================
  # JOB 4: Deploy to Production
  # ============================================
  deploy-production:
    name: ğŸš€ Deploy to Production
    runs-on: ubuntu-latest
    needs: [pre-deployment, backup-deployment, health-check-pre]
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      - name: ğŸ“¤ Copy deployment files
        run: |
          echo "ğŸ“¤ Copying deployment files to server..."
          # Copy docker-compose files
          scp docker-compose.prod.yml root@${{ secrets.PRODUCTION_HOST }}:/root/
          scp docker-compose.swarm.yml root@${{ secrets.PRODUCTION_HOST }}:/root/
          echo "âœ… Files copied successfully"

      - name: ğŸ” Configure environment variables
        run: |
          ssh root@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
          echo "ğŸ” Configuring environment variables..."
          
          # Create .env file with all secrets
          cat > /root/.env <<EOF
          # =====================================
          # ğŸ”¥ FIREFIGHTER AI - PRODUCCIÃ“N
          # =====================================
          
          # ğŸ—„ï¸ MongoDB
          MONGODB_URI=${{ secrets.MONGODB_URI }}
          MONGO_URI=${{ secrets.MONGODB_URI }}
          DB_NAME=FIREFIGHTER
          
          # ğŸ” Seguridad - JWT
          SECRET_KEY=${{ secrets.JWT_SECRET }}
          JWT_SECRET_KEY=${{ secrets.JWT_SECRET }}
          FRONTEND_SECRET_KEY=${{ secrets.JWT_SECRET }}
          BACKOFFICE_SECRET_KEY=${{ secrets.JWT_SECRET }}
          SESSION_SECRET=${{ secrets.JWT_SECRET }}
          JWT_ACCESS_TOKEN_EXPIRE_HOURS=24
          
          # ğŸŒ URLs - Docker Network
          ENVIRONMENT=production
          API_BASE_URL=http://backend:5000
          FRONTEND_URL=http://frontend:8000
          BACKOFFICE_URL=http://backoffice:3001
          
          # URLs internas Docker
          FRONTEND_API_BASE_URL=http://backend:5000
          BACKOFFICE_API_BASE_URL=http://backend:5000
          
          # ğŸ³ Redis
          REDIS_URL=redis://redis:6379/0
          
          # ğŸ‘¤ Admin
          ADMIN_USERNAME=admin
          ADMIN_PASSWORD=${{ secrets.ADMIN_PASSWORD }}
          
          # ğŸ”’ MFA
          MFA_ISSUER=FirefighterAI
          
          # ğŸ“§ Email
          SENDGRID_API_KEY=${{ secrets.SENDGRID_API_KEY }}
          SENDGRID_SENDER_EMAIL=${{ secrets.SENDGRID_SENDER_EMAIL }}
          SENDGRID_SENDER_NAME=FirefighterAI
          
          # ğŸ¤– AI
          ANTHROPIC_API_KEY=${{ secrets.ANTHROPIC_API_KEY }}
          
          # ğŸš€ Production Settings
          DEBUG=false
          LOG_LEVEL=info
          FLASK_ENV=production
          NODE_ENV=production
          DOCKER_ENV=true
          
          # ğŸ”§ Sesiones
          SESSION_PROTECTION=strong
          SESSION_REFRESH_EACH_REQUEST=false
          PERMANENT_SESSION_LIFETIME=43200
          EOF
          
          chmod 600 /root/.env
          echo "âœ… Environment variables configured"
          ENDSSH

      - name: ğŸš€ Deploy updated services
        run: |
          ssh root@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
          cd /root
          
          # Exportar IMAGE_TAG con SHA corto
          export IMAGE_TAG="${{ needs.pre-deployment.outputs.image_tag }}"
          echo "ğŸ“¦ Using image tag: $IMAGE_TAG"
          
          # Pull latest images con el tag especÃ­fico
          echo "ğŸ“¥ Pulling images..."
          docker-compose -f docker-compose.prod.yml pull
          
          # Deploy with zero-downtime
          echo "ğŸš€ Deploying services..."
          docker-compose -f docker-compose.prod.yml up -d --remove-orphans
          
          # Wait for services to be healthy
          echo "â³ Waiting for services to become healthy..."
          for service in backend frontend backoffice redis; do
            for i in {1..30}; do
              if docker inspect --format='{{.State.Health.Status}}' ${service}-prod 2>/dev/null | grep -q healthy; then
                echo "âœ… $service is healthy"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "âŒ $service failed health check after 5 minutes"
                exit 1
              fi
              echo "â³ Attempt $i/30: Waiting for $service..."
              sleep 10
            done
          done
          
          echo "âœ… All services updated successfully"
          ENDSSH

      - name: ğŸ§¹ Cleanup old images
        run: |
          ssh root@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
          echo "ğŸ§¹ Cleaning up old Docker images..."
          
          # Remove dangling images
          docker image prune -f
          
          # Remove old images (keep last 3 versions)
          docker images --format "{{.Repository}}:{{.Tag}}" | \
            grep "${{ env.IMAGE_PREFIX }}" | \
            tail -n +4 | \
            xargs -r docker rmi || true
          
          echo "âœ… Cleanup completed"
          ENDSSH

  # ============================================
  # JOB 5: Post-deployment Health Check
  # ============================================
  health-check-post:
    name: ğŸ¥ Health Check (Post-deployment)
    runs-on: ubuntu-latest
    needs: [deploy-production]
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: â³ Wait for services to stabilize
        run: |
          echo "â³ Waiting 30 seconds for services to stabilize..."
          sleep 30

      - name: ğŸ¥ Comprehensive health check
        id: health-check
        run: |
          echo "ğŸ¥ Running comprehensive health checks..."
          
          MAX_RETRIES=10
          RETRY_DELAY=10
          ALL_HEALTHY=false
          
          for i in $(seq 1 $MAX_RETRIES); do
            echo "ğŸ”„ Health check attempt $i/$MAX_RETRIES"
            
            # Check frontend (usar / en vez de /health)
            FRONTEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.PRODUCTION_HOST }}:8000/ || echo "000")
            echo "  Frontend: $FRONTEND_STATUS"
            
            # Check API (usar /api/health en vez de /health)
            API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.PRODUCTION_HOST }}:5000/api/health || echo "000")
            echo "  API: $API_STATUS"
            
            # Check BackOffice
            BO_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.PRODUCTION_HOST }}:3001/health || echo "000")
            echo "  BackOffice: $BO_STATUS"
            
            # Check if all services are healthy
            if [ "$FRONTEND_STATUS" = "200" ] && [ "$API_STATUS" = "200" ] && [ "$BO_STATUS" = "200" ]; then
              echo "âœ… All services are healthy!"
              ALL_HEALTHY=true
              break
            fi
            
            if [ $i -lt $MAX_RETRIES ]; then
              echo "â³ Waiting ${RETRY_DELAY}s before retry..."
              sleep $RETRY_DELAY
            fi
          done
          
          if [ "$ALL_HEALTHY" = false ]; then
            echo "âŒ Health check failed after $MAX_RETRIES attempts"
            echo "health_status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "health_status=success" >> $GITHUB_OUTPUT

      - name: ğŸ“Š Create health report
        if: always()
        run: |
          # Get detailed service info (corregir URLs)
          FRONTEND_RESPONSE=$(curl -s http://${{ secrets.PRODUCTION_HOST }}:8000/ || echo "{}")
          API_RESPONSE=$(curl -s http://${{ secrets.PRODUCTION_HOST }}:5000/api/health || echo "{}")
          BO_RESPONSE=$(curl -s http://${{ secrets.PRODUCTION_HOST }}:3001/health || echo "{}")
          
          cat > health-report-post.json <<EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "frontend": {
              "status": "$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.PRODUCTION_HOST }}:8000/ || echo "000")"
            },
            "api": {
              "status": "$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.PRODUCTION_HOST }}:5000/api/health || echo "000")"
            },
            "backoffice": {
              "status": "$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.PRODUCTION_HOST }}:3001/health || echo "000")"
            }
          }
          EOF
          
          cat health-report-post.json

  # ============================================
  # JOB 6: Deployment Success Handler
  # ============================================
  deployment-success:
    name: âœ… Deployment Success
    runs-on: ubuntu-latest
    needs: [pre-deployment, deploy-production, health-check-post]
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ“Š Create deployment summary
        run: |
          cat > deployment-info-final.json <<EOF
          {
            "deployment_id": "${{ needs.pre-deployment.outputs.deployment_id }}",
            "image_tag": "${{ needs.pre-deployment.outputs.image_tag }}",
            "commit_sha": "${{ github.sha }}",
            "deployed_by": "${{ github.actor }}",
            "completed_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "status": "success"
          }
          EOF
          cat deployment-info-final.json

      - name: ğŸ‰ Success notification
        run: |
          echo "# ğŸ‰ Deployment Successful!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment ID:** ${{ needs.pre-deployment.outputs.deployment_id }}" >> $GITHUB_STEP_SUMMARY
          echo "**Image Tag:** ${{ needs.pre-deployment.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Time:** $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Services Status" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Frontend: http://${{ secrets.PRODUCTION_HOST }}:8000" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… API: http://${{ secrets.PRODUCTION_HOST }}:5000" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… BackOffice: http://${{ secrets.PRODUCTION_HOST }}:3001" >> $GITHUB_STEP_SUMMARY

      - name: ğŸ“¢ Create deployment annotation
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createCommitComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha,
              body: `ğŸš€ Successfully deployed to production\n\nDeployment ID: ${{ needs.pre-deployment.outputs.deployment_id }}\nImage Tag: ${{ needs.pre-deployment.outputs.image_tag }}\nTime: ${new Date().toISOString()}`
            });

  # ============================================
  # JOB 7: Deployment Failure Handler
  # ============================================
  deployment-failure:
    name: âŒ Deployment Failure Handler
    runs-on: ubuntu-latest
    needs: [deploy-production, health-check-post]
    if: failure()
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      - name: ğŸ“Š Collect failure logs
        run: |
          ssh root@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
          echo "ğŸ“Š Collecting failure logs..."
          mkdir -p /root/failed-deployments
          FAILURE_DIR="/root/failed-deployments/$(date +%Y%m%d-%H%M%S)"
          mkdir -p "$FAILURE_DIR"
          
          # Collect service logs
          docker-compose -f docker-compose.prod.yml logs --tail=500 > "$FAILURE_DIR/docker-logs.txt" 2>&1 || true
          
          # Collect service status
          docker ps -a > "$FAILURE_DIR/container-status.txt"
          docker service ls > "$FAILURE_DIR/service-status.txt" 2>/dev/null || true
          
          # Collect system info
          df -h > "$FAILURE_DIR/disk-usage.txt"
          free -h > "$FAILURE_DIR/memory-usage.txt"
          
          echo "âœ… Logs collected: $FAILURE_DIR"
          ENDSSH

      - name: âŒ Failure notification
        run: |
          echo "# âŒ Deployment Failed!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Failed at:** $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Review the logs in the failed-deployments directory" >> $GITHUB_STEP_SUMMARY
          echo "2. Check health check results" >> $GITHUB_STEP_SUMMARY
          echo "3. Consider triggering a rollback if needed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âš ï¸ **System remains on previous version**" >> $GITHUB_STEP_SUMMARY

      - name: ğŸ“¢ Create failure annotation
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createCommitComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha,
              body: `âŒ Deployment failed\n\nTime: ${new Date().toISOString()}\n\nâš ï¸ System remains on previous version. Review logs and consider rollback if needed.`
            });
