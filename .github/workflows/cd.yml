name: CD Pipeline - Simplified & Functional

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  DOCKER_REGISTRY: ghcr.io

jobs:
  build_and_deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate image tags
        id: tags
        run: |
          REPO_OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          echo "backend=${{ env.DOCKER_REGISTRY }}/${REPO_OWNER}/ai-firefighter-backend" >> $GITHUB_OUTPUT
          echo "frontend=${{ env.DOCKER_REGISTRY }}/${REPO_OWNER}/ai-firefighter-frontend" >> $GITHUB_OUTPUT

      - name: Build and push Backend
        uses: docker/build-push-action@v5
        with:
          context: ./API
          file: ./API/Dockerfile
          push: true
          tags: |
            ${{ steps.tags.outputs.backend }}:latest
            ${{ steps.tags.outputs.backend }}:${{ github.sha }}
          cache-from: type=gha,scope=backend
          cache-to: type=gha,mode=max,scope=backend

      - name: Build and push Frontend
        uses: docker/build-push-action@v5
        with:
          context: ./FO
          file: ./FO/Dockerfile
          push: true
          tags: |
            ${{ steps.tags.outputs.frontend }}:latest
            ${{ steps.tags.outputs.frontend }}:${{ github.sha }}
          cache-from: type=gha,scope=frontend
          cache-to: type=gha,mode=max,scope=frontend

      - name: Create deployment script
        run: |
          cat > deploy.sh << 'SCRIPT_EOF'
          #!/bin/bash
          set -e
          
          cd /opt/firefighter-app || { mkdir -p /opt/firefighter-app && cd /opt/firefighter-app; }
          
          # Stop and remove old containers
          docker stop $(docker ps -aq) 2>/dev/null || true
          docker rm $(docker ps -aq) 2>/dev/null || true
          
          # Login to registry
          echo "$GITHUB_TOKEN" | docker login ghcr.io -u "$GITHUB_ACTOR" --password-stdin
          
          # Pull latest images
          docker pull "$BACKEND_IMAGE"
          docker pull "$FRONTEND_IMAGE"
          
          # Create docker-compose.yml
          cat > docker-compose.yml << 'COMPOSE_EOF'
          version: '3.8'
          services:
            backend:
              image: BACKEND_IMAGE_PLACEHOLDER
              container_name: firefighter-backend
              ports:
                - "5000:5000"
              environment:
                - DB_USERNAME=${DB_USERNAME}
                - DB_PASSWORD=${DB_PASSWORD}
                - DB_CLUSTER=${DB_CLUSTER}
                - FLASK_ENV=production
              restart: unless-stopped
          
            frontend:
              image: FRONTEND_IMAGE_PLACEHOLDER
              container_name: firefighter-frontend
              ports:
                - "8000:8000"
              environment:
                - FLASK_ENV=production
                - API_BASE_URL=http://backend:5000/api
              depends_on:
                - backend
              restart: unless-stopped
          COMPOSE_EOF
          
          # Replace placeholders
          sed -i "s|BACKEND_IMAGE_PLACEHOLDER|$BACKEND_IMAGE|g" docker-compose.yml
          sed -i "s|FRONTEND_IMAGE_PLACEHOLDER|$FRONTEND_IMAGE|g" docker-compose.yml
          
          # Create .env file
          cat > .env << 'ENV_EOF'
          DB_USERNAME=${DB_USERNAME}
          DB_PASSWORD=${DB_PASSWORD}
          DB_CLUSTER=${DB_CLUSTER}
          ENV_EOF
          
          # Replace env vars in .env
          sed -i "s|\${DB_USERNAME}|$DB_USERNAME|g" .env
          sed -i "s|\${DB_PASSWORD}|$DB_PASSWORD|g" .env
          sed -i "s|\${DB_CLUSTER}|$DB_CLUSTER|g" .env
          
          # Deploy
          docker-compose up -d
          
          # Wait and verify
          echo "Waiting for services to start..."
          sleep 30
          
          if curl -sf http://localhost:5000/ && curl -sf http://localhost:8000/; then
            echo "✅ Deployment successful"
            exit 0
          else
            echo "❌ Deployment verification failed"
            docker-compose logs
            exit 1
          fi
          SCRIPT_EOF
          
          chmod +x deploy.sh

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy to production
        run: |
          # Upload script
          scp deploy.sh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }}:/tmp/
          
          # Execute deployment
          ssh ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} \
            "export GITHUB_TOKEN='${{ secrets.GITHUB_TOKEN }}' \
             GITHUB_ACTOR='${{ github.actor }}' \
             BACKEND_IMAGE='${{ steps.tags.outputs.backend }}:latest' \
             FRONTEND_IMAGE='${{ steps.tags.outputs.frontend }}:latest' \
             DB_USERNAME='${{ secrets.DB_USERNAME }}' \
             DB_PASSWORD='${{ secrets.DB_PASSWORD }}' \
             DB_CLUSTER='${{ secrets.DB_CLUSTER }}' && \
             bash /tmp/deploy.sh"

      - name: Verify deployment
        run: |
          sleep 10
          if curl -sf http://${{ secrets.PRODUCTION_HOST }}:8000/ && \
             curl -sf http://${{ secrets.PRODUCTION_HOST }}:5000/; then
            echo "✅ All services are running"
            echo "Frontend: http://${{ secrets.PRODUCTION_HOST }}:8000"
            echo "Backend: http://${{ secrets.PRODUCTION_HOST }}:5000"
          else
            echo "⚠️ Some services may not be responding"
            exit 1
          fi

      - name: Cleanup
        if: always()
        run: rm -f ~/.ssh/id_rsa

  health_check:
    name: Final Health Check
    runs-on: ubuntu-latest
    needs: build_and_deploy
    if: always()

    steps:
      - name: Check services
        run: |
          echo "Checking services..."
          sleep 20
          
          FRONTEND_UP=false
          BACKEND_UP=false
          
          curl -sf http://${{ secrets.PRODUCTION_HOST }}:8000/ && FRONTEND_UP=true
          curl -sf http://${{ secrets.PRODUCTION_HOST }}:5000/ && BACKEND_UP=true
          
          if [ "$FRONTEND_UP" = true ] && [ "$BACKEND_UP" = true ]; then
            echo "✅ HEALTHY - All services running"
            echo "Frontend: http://${{ secrets.PRODUCTION_HOST }}:8000"
            echo "Backend: http://${{ secrets.PRODUCTION_HOST }}:5000"
          elif [ "$FRONTEND_UP" = true ]; then
            echo "⚠️ DEGRADED - Only frontend running"
          else
            echo "❌ CRITICAL - Services down"
            exit 1
          fi