name: üöÄ CD - Continuous Deployment

on:
  workflow_run:
    workflows: ["üî¨ CI - Continuous Integration"]
    types: [completed]
    branches: [main]

permissions:
  contents: read
  packages: read
  id-token: write

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: josojmf/ai-firefighter
  DEPLOYMENT_TIMEOUT: 600 # 10 minutes

jobs:
  # ============================================
  # JOB 1: Pre-deployment Validation
  # ============================================
  pre-deployment:
    name: üîç Pre-deployment Validation
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    outputs:
      deployment_id: ${{ steps.generate-id.outputs.deployment_id }}
      image_tag: ${{ steps.image-tag.outputs.tag }}
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: üÜî Generate deployment ID
        id: generate-id
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          DEPLOYMENT_ID="deploy-${TIMESTAMP}-${SHORT_SHA}"
          echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "üÜî Deployment ID: $DEPLOYMENT_ID"

      - name: üè∑Ô∏è Generate image tag
        id: image-tag
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          IMAGE_TAG="main-${SHORT_SHA}"
          echo "tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "üè∑Ô∏è Image tag: ${IMAGE_TAG}"

      - name: Validate required secrets
        run: |
          echo "üîí Validating required secrets..."
          
          # Verificar cada secret individualmente
          REQUIRED_SECRETS="PRODUCTION_SSH_KEY PRODUCTION_HOST MONGODB_URI JWT_SECRET SENDGRID_API_KEY ANTHROPIC_API_KEY ADMIN_PASSWORD SENDGRID_SENDER_EMAIL"
          
          for secret_name in $REQUIRED_SECRETS; do
            case $secret_name in
              PRODUCTION_SSH_KEY)
                if [ -z "${{ secrets.PRODUCTION_SSH_KEY }}" ]; then
                  echo "‚ùå ERROR: Secret 'PRODUCTION_SSH_KEY' is missing!"
                  exit 1
                fi
                echo "‚úÖ PRODUCTION_SSH_KEY: Configured"
                ;;
              PRODUCTION_HOST)
                if [ -z "${{ secrets.PRODUCTION_HOST }}" ]; then
                  echo "‚ùå ERROR: Secret 'PRODUCTION_HOST' is missing!"
                  exit 1
                fi
                echo "‚úÖ PRODUCTION_HOST: Configured"
                ;;
              MONGODB_URI)
                if [ -z "${{ secrets.MONGODB_URI }}" ]; then
                  echo "‚ùå ERROR: Secret 'MONGODB_URI' is missing!"
                  exit 1
                fi
                echo "‚úÖ MONGODB_URI: Configured"
                ;;
              JWT_SECRET)
                if [ -z "${{ secrets.JWT_SECRET }}" ]; then
                  echo "‚ùå ERROR: Secret 'JWT_SECRET' is missing!"
                  exit 1
                fi
                echo "‚úÖ JWT_SECRET: Configured"
                ;;
              SENDGRID_API_KEY)
                if [ -z "${{ secrets.SENDGRID_API_KEY }}" ]; then
                  echo "‚ùå ERROR: Secret 'SENDGRID_API_KEY' is missing!"
                  exit 1
                fi
                echo "‚úÖ SENDGRID_API_KEY: Configured"
                ;;
              ANTHROPIC_API_KEY)
                if [ -z "${{ secrets.ANTHROPIC_API_KEY }}" ]; then
                  echo "‚ùå ERROR: Secret 'ANTHROPIC_API_KEY' is missing!"
                  exit 1
                fi
                echo "‚úÖ ANTHROPIC_API_KEY: Configured"
                ;;
              ADMIN_PASSWORD)
                if [ -z "${{ secrets.ADMIN_PASSWORD }}" ]; then
                  echo "‚ùå ERROR: Secret 'ADMIN_PASSWORD' is missing!"
                  exit 1
                fi
                echo "‚úÖ ADMIN_PASSWORD: Configured"
                ;;
              SENDGRID_SENDER_EMAIL)
                if [ -z "${{ secrets.SENDGRID_SENDER_EMAIL }}" ]; then
                  echo "‚ùå ERROR: Secret 'SENDGRID_SENDER_EMAIL' is missing!"
                  exit 1
                fi
                echo "‚úÖ SENDGRID_SENDER_EMAIL: Configured"
                ;;
            esac
          done
          
          echo "‚úÖ All required secrets are configured"

  # ============================================
  # JOB 2: Deploy to Production
  # ============================================
  deploy-production:
    name: üöÄ Deploy to Production
    runs-on: ubuntu-latest
    needs: [pre-deployment]
    environment:
      name: production
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîß Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H "${{ secrets.PRODUCTION_HOST }}" >> ~/.ssh/known_hosts 2>/dev/null
          echo "‚úÖ SSH configured"

      - name: üì§ Copy docker-compose file
        run: |
          echo "üì§ Copying docker-compose.prod.yml to server..."
          scp docker-compose.prod.yml root@${{ secrets.PRODUCTION_HOST }}:/root/
          echo "‚úÖ File copied"

      - name: üîê Create .env file on server
        run: |
          echo "üîê Creating .env file on server..."
          
          ssh root@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
          set -e
          
          echo "üìù Creating .env file..."
          
          cat > /root/.env <<EOF
          # =====================================
          # üî• FIREFIGHTER AI - PRODUCTION
          # =====================================
          # üê≥ Auto-generated by GitHub Actions
          # Deployment ID: ${{ needs.pre-deployment.outputs.deployment_id }}
          # =====================================

          # üóÑÔ∏è MongoDB
          MONGODB_URI=${{ secrets.MONGODB_URI }}
          MONGO_URI=${{ secrets.MONGODB_URI }}
          DB_NAME=FIREFIGHTER

          # üîê Security
          SECRET_KEY=${{ secrets.JWT_SECRET }}
          JWT_SECRET_KEY=${{ secrets.JWT_SECRET }}
          FRONTEND_SECRET_KEY=${{ secrets.JWT_SECRET }}
          BACKOFFICE_SECRET_KEY=${{ secrets.JWT_SECRET }}
          SESSION_SECRET=${{ secrets.JWT_SECRET }}
          JWT_ACCESS_TOKEN_EXPIRE_HOURS=24

          # üë§ Admin (CRITICAL - MUST BE SET)
          ADMIN_USERNAME=admin
          ADMIN_PASSWORD=${{ secrets.ADMIN_PASSWORD }}

          # üåê URLs
          ENVIRONMENT=production
          API_BASE_URL=http://backend:5000
          FRONTEND_URL=http://frontend:8000
          BACKOFFICE_URL=http://backoffice:3001
          FRONTEND_API_BASE_URL=http://backend:5000
          BACKOFFICE_API_BASE_URL=http://backend:5000

          # üê≥ Redis
          REDIS_URL=redis://redis:6379/0

          # üîí MFA
          MFA_ISSUER=FirefighterAI

          # üìß Email
          SENDGRID_API_KEY=${{ secrets.SENDGRID_API_KEY }}
          SENDGRID_SENDER_EMAIL=${{ secrets.SENDGRID_SENDER_EMAIL }}
          SENDGRID_SENDER_NAME=FirefighterAI

          # ü§ñ AI
          ANTHROPIC_API_KEY=${{ secrets.ANTHROPIC_API_KEY }}

          # üöÄ Production Settings
          DEBUG=false
          LOG_LEVEL=info
          FLASK_ENV=production
          NODE_ENV=production
          DOCKER_ENV=true

          # üîß Sessions
          SESSION_PROTECTION=strong
          SESSION_REFRESH_EACH_REQUEST=false
          PERMANENT_SESSION_LIFETIME=43200

          # üê≥ Docker Config
          IMAGE_TAG=${{ needs.pre-deployment.outputs.image_tag }}
          REGISTRY=${{ env.REGISTRY }}
          IMAGE_PREFIX=${{ env.IMAGE_PREFIX }}

          # üöÄ Deployment Info
          DEPLOYMENT_ID=${{ needs.pre-deployment.outputs.deployment_id }}
          COMMIT_SHA=${{ github.sha }}
          DEPLOYED_AT=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          EOF

          echo "üîç Verifying .env file..."
          ls -la /root/.env
          
          # Verify ADMIN_PASSWORD is not empty
          if grep -q 'ADMIN_PASSWORD=$' /root/.env; then
            echo "‚ùå ERROR: ADMIN_PASSWORD is empty!"
            exit 1
          fi
          
          PASSWORD_LENGTH=$(grep 'ADMIN_PASSWORD=' /root/.env | cut -d'=' -f2 | tr -d '\n' | wc -c)
          echo "‚úÖ ADMIN_PASSWORD length: $PASSWORD_LENGTH characters"
          
          chmod 600 /root/.env
          echo "‚úÖ .env file created and secured"
          ENDSSH

      - name: üê≥ Login to GHCR
        run: |
          ssh root@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
          echo "üîê Logging into GitHub Container Registry..."
          
          # Try to login
          if echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin; then
            echo "‚úÖ Logged into GHCR"
          else
            echo "‚ùå Failed to login to GHCR"
            exit 1
          fi
          ENDSSH

      - name: üöÄ Deploy with docker-compose
        run: |
          ssh root@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
          set -e
          
          echo "üöÄ Starting deployment..."
          cd /root
          
          # Stop old containers if they exist
          echo "üõë Stopping old containers..."
          docker-compose -f docker-compose.prod.yml down 2>/dev/null || true
          
          # Pull new images
          echo "üì• Pulling new images..."
          export IMAGE_TAG="${{ needs.pre-deployment.outputs.image_tag }}"
          docker-compose -f docker-compose.prod.yml pull
          
          # Start services
          echo "üöÄ Starting services..."
          docker-compose -f docker-compose.prod.yml up -d
          
          echo "‚úÖ Services started"
          ENDSSH

      - name: ‚è≥ Wait for services to start
        run: |
          ssh root@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
          echo "‚è≥ Waiting for services to be ready..."
          
          # Wait for all containers to be running
          for i in {1..30}; do
            RUNNING_CONTAINERS=$(docker ps -q --filter "name=.*-prod" | wc -l)
            TOTAL_CONTAINERS=4  # backend, frontend, backoffice, redis
            
            if [ "$RUNNING_CONTAINERS" -eq "$TOTAL_CONTAINERS" ]; then
              echo "‚úÖ All $TOTAL_CONTAINERS containers are running"
              break
            fi
            
            echo "‚è≥ Containers running: $RUNNING_CONTAINERS/$TOTAL_CONTAINERS (attempt $i/30)"
            
            if [ $i -eq 30 ]; then
              echo "‚ùå Timeout waiting for containers"
              docker ps -a
              exit 1
            fi
            
            sleep 5
          done
          
          # Extra wait for services to be fully ready
          echo "‚è≥ Waiting extra 15 seconds for services to stabilize..."
          sleep 15
          
          echo "‚úÖ Services are ready"
          ENDSSH

      - name: üè• Verify services are working
        run: |
          ssh root@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
          echo "üè• Verifying services are responding..."
          
          HOST="localhost"
          
          # Check Backend
          echo "üîç Checking backend..."
          for i in {1..10}; do
            if curl -f -s http://$HOST:5000/api/health > /dev/null; then
              echo "‚úÖ Backend is healthy"
              break
            fi
            
            if [ $i -eq 10 ]; then
              echo "‚ùå Backend is not responding"
              docker logs backend-prod --tail 20
              exit 1
            fi
            
            echo "‚è≥ Backend not ready yet (attempt $i/10)"
            sleep 5
          done
          
          # Check Frontend
          echo "üîç Checking frontend..."
          for i in {1..10}; do
            if curl -f -s http://$HOST:8000/ > /dev/null; then
              echo "‚úÖ Frontend is healthy"
              break
            fi
            
            if [ $i -eq 10 ]; then
              echo "‚ùå Frontend is not responding"
              docker logs frontend-prod --tail 20
              exit 1
            fi
            
            echo "‚è≥ Frontend not ready yet (attempt $i/10)"
            sleep 5
          done
          
          # Check Backoffice
          echo "üîç Checking backoffice..."
          for i in {1..10}; do
            if curl -f -s http://$HOST:3001/health > /dev/null; then
              echo "‚úÖ Backoffice is healthy"
              break
            fi
            
            if [ $i -eq 10 ]; then
              echo "‚ùå Backoffice is not responding"
              docker logs backoffice-prod --tail 20
              exit 1
            fi
            
            echo "‚è≥ Backoffice not ready yet (attempt $i/10)"
            sleep 5
          done
          
          echo "üéâ All services are working correctly!"
          ENDSSH

      - name: üìä Show deployment status
        run: |
          ssh root@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
          echo "üìä Deployment Status:"
          echo ""
          echo "üê≥ Running containers:"
          docker ps --format "table {{.Names}}\t{{.Image}}\t{{.Status}}"
          
          echo ""
          echo "üåê Services accessible at:"
          PUBLIC_IP=$(curl -s ifconfig.me 2>/dev/null || hostname -I | awk '{print $1}')
          echo "   - Frontend:   http://${PUBLIC_IP}:8000"
          echo "   - API:        http://${PUBLIC_IP}:5000"
          echo "   - BackOffice: http://${PUBLIC_IP}:3001"
          ENDSSH

      - name: üßπ Cleanup old images
        run: |
          ssh root@${{ secrets.PRODUCTION_HOST }} << 'ENDSSH'
          echo "üßπ Cleaning up old Docker images..."
          
          # Remove dangling images
          docker image prune -f 2>/dev/null || true
          
          echo "‚úÖ Cleanup completed"
          ENDSSH

  # ============================================
  # JOB 3: Deployment Success
  # ============================================
  deployment-success:
    name: ‚úÖ Deployment Success
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: success()
    
    steps:
      - name: üéâ Success notification
        run: |
          echo "# üéâ Deployment Successful!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment ID:** ${{ needs.pre-deployment.outputs.deployment_id }}" >> $GITHUB_STEP_SUMMARY
          echo "**Image Tag:** ${{ needs.pre-deployment.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Time:** $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Services Status" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ Frontend: http://${{ secrets.PRODUCTION_HOST }}:8000" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ API: http://${{ secrets.PRODUCTION_HOST }}:5000" >> $GITHUB_STEP_SUMMARY
          echo "- ‚úÖ BackOffice: http://${{ secrets.PRODUCTION_HOST }}:3001" >> $GITHUB_STEP_SUMMARY

  # ============================================
  # JOB 4: Deployment Failure
  # ============================================
  deployment-failure:
    name: ‚ùå Deployment Failure
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: failure()
    
    steps:
      - name: ‚ùå Failure notification
        run: |
          echo "# ‚ùå Deployment Failed!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Failed at:** $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Check the logs above for errors" >> $GITHUB_STEP_SUMMARY
          echo "2. SSH into the server and run:" >> $GITHUB_STEP_SUMMARY
          echo "   \`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "   cd /root" >> $GITHUB_STEP_SUMMARY
          echo "   docker-compose -f docker-compose.prod.yml logs" >> $GITHUB_STEP_SUMMARY
          echo "   \`\`\`" >> $GITHUB_STEP_SUMMARY