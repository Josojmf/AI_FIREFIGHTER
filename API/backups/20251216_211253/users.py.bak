"""
User Routes - User management endpoints
=======================================
"""

from fastapi import APIRouter, HTTPException, Depends
from typing import Dict, Any
from datetime import datetime
from bson import ObjectId
from bson.errors import InvalidId

router = APIRouter()

# ============================================================================
# DEPENDENCIAS - FIXED VERSION
# ============================================================================

async def require_user():
    """Dependency para usuario autenticado"""
    # Import the actual dependency function, don't call it!
    from dependencies.auth import require_user as auth_require_user
    # Return the dependency itself (FastAPI will call it)
    return Depends(auth_require_user)

async def require_admin():
    """Dependency para admin"""
    # Import the actual dependency function
    from dependencies.auth import require_admin as auth_require_admin
    # Return the dependency itself (FastAPI will call it)
    return Depends(auth_require_admin)

# Better approach: Import directly at the top
from dependencies.auth import require_user as dep_require_user
from dependencies.auth import require_admin as dep_require_admin

# ============================================================================
# ENDPOINTS
# ============================================================================

@router.get("/users", response_model=Dict[str, Any])
async def list_users(admin_data: Dict = Depends(dep_require_admin)):
    """Listar todos los usuarios (solo admin)"""
    try:
        from api import db, serialize_doc
        
        print(f"üîç GET /api/users - Admin: {admin_data['username']}")
        
        # Obtener usuarios
        cursor = db.users.find({}, {
            'password': 0,
            'password_hash': 0,
            'mfa_secret': 0
        })
        
        users_list = await cursor.to_list(length=1000)
        
        # Procesar usuarios
        processed_users = []
        for user in users_list:
            user_data = serialize_doc(user)
            
            # Asegurar campos requeridos
            user_data.setdefault('email_verified', False)
            user_data.setdefault('mfa_enabled', False)
            user_data.setdefault('has_leitner_progress', False)
            user_data.setdefault('has_backoffice_cards', False)
            user_data.setdefault('metadata', {})
            user_data.setdefault('status', 'active')
            user_data.setdefault('role', 'user')
            
            # Formatear fechas
            for date_field in ['created_at', 'last_login']:
                if date_field in user_data and isinstance(user_data[date_field], datetime):
                    user_data[date_field] = user_data[date_field].isoformat()
            
            processed_users.append(user_data)
        
        print(f"‚úÖ Usuarios encontrados: {len(processed_users)}")
        
        return {'ok': True, 'users': processed_users}
        
    except Exception as e:
        print(f"‚ùå Error obteniendo usuarios: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"Error interno: {str(e)}")

@router.get("/users/{user_id}", response_model=Dict[str, Any])
async def get_user(user_id: str, user_data: Dict = Depends(dep_require_user)):
    """Obtener detalle de usuario"""
    try:
        from api import db, serialize_doc
        
        # Verificar permisos
        if user_data.get('role') != 'admin' and user_data.get('user_id') != user_id:
            raise HTTPException(status_code=403, detail="Acceso denegado")
        
        print(f"üîç GET /api/users/{user_id}")
        
        try:
            oid = ObjectId(user_id)
            user = await db.users.find_one({"_id": oid})
        except InvalidId:
            # Buscar por username
            user = await db.users.find_one({"username": user_id})
        
        if not user:
            raise HTTPException(status_code=404, detail="Usuario no encontrado")
        
        # Serializar
        result_user_data = serialize_doc(user)
        
        # Asegurar campos
        result_user_data.setdefault('email_verified', False)
        result_user_data.setdefault('mfa_enabled', False)
        result_user_data.setdefault('has_leitner_progress', False)
        result_user_data.setdefault('has_backoffice_cards', False)
        result_user_data.setdefault('metadata', {})
        
        return {"ok": True, "user": result_user_data}
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå Error obteniendo usuario: {e}")
        raise HTTPException(status_code=500, detail=f"Error interno: {str(e)}")

@router.get("/users/me", response_model=Dict[str, Any])
async def get_current_user(user_data: Dict = Depends(dep_require_user)):
    """Obtener informaci√≥n del usuario actual"""
    try:
        from api import db, serialize_doc
        
        user_id = user_data.get('user_id')
        print(f"üîç GET /api/users/me - User ID: {user_id}")
        
        try:
            oid = ObjectId(user_id)
            user = await db.users.find_one({"_id": oid})
        except InvalidId:
            # Buscar por username
            user = await db.users.find_one({"username": user_data['username']})
        
        if not user:
            raise HTTPException(status_code=404, detail="Usuario no encontrado")
        
        # Serializar
        result_user_data = serialize_doc(user)
        
        # Asegurar campos
        result_user_data.setdefault('email_verified', False)
        result_user_data.setdefault('mfa_enabled', False)
        result_user_data.setdefault('has_leitner_progress', False)
        result_user_data.setdefault('has_backoffice_cards', False)
        result_user_data.setdefault('metadata', {})
        
        return {"ok": True, "user": result_user_data}
        
    except Exception as e:
        print(f"‚ùå Error obteniendo usuario actual: {e}")
        raise HTTPException(status_code=500, detail=f"Error interno: {str(e)}")

@router.patch("/users/{user_id}", response_model=Dict[str, Any])
async def update_user(
    user_id: str,
    updates: Dict[str, Any],
    user_data: Dict = Depends(dep_require_user)
):
    """Actualizar usuario"""
    try:
        from api import db
        
        # Verificar permisos
        if user_data.get('role') != 'admin' and user_data.get('user_id') != user_id:
            raise HTTPException(status_code=403, detail="Acceso denegado")
        
        print(f"üîç PATCH /api/users/{user_id} - Updates: {updates}")
        
        # Campos permitidos
        allowed_fields = ['email', 'name', 'status', 'mfa_enabled']
        if user_data.get('role') == 'admin':
            allowed_fields.append('role')
        
        # Filtrar updates
        update_dict = {}
        for field in allowed_fields:
            if field in updates and updates[field] is not None:
                update_dict[field] = updates[field]
        
        if not update_dict:
            return {"ok": True, "message": "No hay cambios"}
        
        update_dict['updated_at'] = datetime.utcnow()
        
        try:
            oid = ObjectId(user_id)
        except InvalidId:
            raise HTTPException(status_code=400, detail="ID de usuario inv√°lido")
        
        # Actualizar
        result = await db.users.update_one(
            {"_id": oid},
            {"$set": update_dict}
        )
        
        if result.modified_count == 0:
            raise HTTPException(status_code=404, detail="Usuario no encontrado o sin cambios")
        
        return {"ok": True, "message": "Usuario actualizado"}
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå Error actualizando usuario: {e}")
        raise HTTPException(status_code=500, detail=f"Error interno: {str(e)}")

@router.delete("/users/{user_id}", response_model=Dict[str, Any])
async def delete_user(user_id: str, admin_data: Dict = Depends(dep_require_admin)):
    """Eliminar usuario (solo admin)"""
    try:
        from api import db
        
        # No permitir auto-eliminaci√≥n
        if admin_data.get('user_id') == user_id:
            raise HTTPException(
                status_code=400,
                detail="No puedes eliminar tu propia cuenta"
            )
        
        print(f"üîç DELETE /api/users/{user_id}")
        
        try:
            oid = ObjectId(user_id)
        except InvalidId:
            raise HTTPException(status_code=400, detail="ID de usuario inv√°lido")
        
        # Marcar como inactivo
        result = await db.users.update_one(
            {"_id": oid},
            {"$set": {"status": "inactive", "deleted_at": datetime.utcnow()}}
        )
        
        if result.modified_count == 0:
            raise HTTPException(status_code=404, detail="Usuario no encontrado")
        
        return {"ok": True, "message": "Usuario desactivado"}
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå Error eliminando usuario: {e}")
        raise HTTPException(status_code=500, detail=f"Error interno: {str(e)}")

@router.get("/users/{user_id}/progress", response_model=Dict[str, Any])
async def get_user_progress(user_id: str, user_data: Dict = Depends(dep_require_user)):
    """Obtener progreso Leitner del usuario"""
    try:
        from api import db
        
        # Verificar permisos
        if user_data.get('role') != 'admin' and user_data.get('user_id') != user_id:
            raise HTTPException(status_code=403, detail="Acceso denegado")
        
        print(f"üîç GET /api/users/{user_id}/progress")
        
        try:
            oid = ObjectId(user_id)
            user = await db.users.find_one({"_id": oid})
        except InvalidId:
            user = await db.users.find_one({"username": user_id})
        
        if not user:
            raise HTTPException(status_code=404, detail="Usuario no encontrado")
        
        # Obtener progreso
        leitner = user.get('leitner_system', {})
        boxes = leitner.get('boxes', {})
        
        progress = {
            "total_cards": sum(len(cards) for cards in boxes.values()),
            "boxes": {str(k): len(v) for k, v in boxes.items()},
            "last_study": leitner.get('last_study'),
            "created_at": leitner.get('created_at'),
            "study_sessions": leitner.get('study_sessions', 0),
            "streak": leitner.get('streak', 0),
            "has_leitner_progress": bool(leitner)
        }
        
        return {"ok": True, "progress": progress}
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå Error obteniendo progreso: {e}")
        raise HTTPException(status_code=500, detail=f"Error interno: {str(e)}")

@router.get("/health/users", response_model=Dict[str, Any])
async def users_health():
    """Health check para router de usuarios"""
    return {
        "ok": True,
        "service": "users",
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat()
    }